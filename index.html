<!DOCTYPE html>

<html lang="en">

<head>

  <meta charset="UTF-8" />

  <meta name="viewport" content="width=device-width,initial-scale=1" />

  <title>Pomoplan</title>

  <style>

    @import url("https://fonts.googleapis.com/css2?family=Comfortaa:wght@500;700&display=swap");



    :root {

      --bg: #141414;

      --card: #232323;

      --text: #f2f2f2;

      --muted: #9a9a9a;

      --border: #3a3a3a;

      --border-soft: #2d2d2d;

      --surface: rgba(255, 255, 255, 0.03);

      --surface-strong: rgba(255, 255, 255, 0.06);

      --primary: #27215e;



      --rowH: 36px;

      --dzH: 3px;

      --checkSize: 14px;

      --radius: 12px;

      --shadow: none;

      --handle: #b7b7b7;

      --focus: #5fb3ff;

      --pastOpacity: 0.45;

      --headerH: 54px;

      --ease: cubic-bezier(0.22, 0.7, 0.2, 1);

      --ease-smooth: cubic-bezier(0.22, 0.8, 0.18, 1);

      --ease-snap: cubic-bezier(0.2, 0.9, 0.25, 1);

      --lift: none;

      --itemPad: 6px 10px;

      --rowPad: 0 12px;

      --dimOpacity: 0.25;

      --countdownSize: 48px;

      --countdownLine: 64px;

    }



    body.light {

      --bg: #f5f5f5;

      --card: #ffffff;

      --text: #222;

      --muted: #777;

      --border: #e3e3e3;

      --handle: #8a8a8a;

      --shadow: 0 6px 26px rgba(0, 0, 0, 0.12);

    }



    * {

      box-sizing: border-box;

      font-family: -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, sans-serif;

    }



    body {

      margin: 0;

      background: var(--bg);

      color: var(--text);

      overflow: hidden;

      background-image:

        radial-gradient(1200px 600px at 90% -10%, rgba(255, 255, 255, 0.08), transparent 60%),

        radial-gradient(800px 400px at 5% 110%, rgba(255, 255, 255, 0.05), transparent 60%),

        linear-gradient(180deg, rgba(255, 255, 255, 0.02), transparent 20%);

      -webkit-font-smoothing: antialiased;

      text-rendering: optimizeLegibility;

    }



    body.dragging {

      cursor: grabbing;

      user-select: none;

    }



    header {

      height: var(--headerH);

      background: var(--primary);

      color: #fff;

      padding: 10px 14px;

      display: grid;

      grid-template-columns: 1fr auto 1fr;

      align-items: center;

      font-weight: 800;

      gap: 12px;

      position: relative;

    }



    .hdr-left {

      display: flex;

      align-items: baseline;

      gap: 10px;

      min-width: 0;

      grid-column: 1;

    }



    .app-title {

      white-space: nowrap;

      font-family: "Comfortaa", "Trebuchet MS", "Segoe UI", sans-serif;

      font-weight: 700;

      font-size: 20px;

      letter-spacing: 0.04em;

      text-transform: lowercase;

      position: absolute;

      left: 50%;

      top: 50%;

      transform: translate(-50%, -50%);

      text-align: center;

      pointer-events: none;

    }



    .countdown {

      font-variant-numeric: tabular-nums;

      opacity: 0.95;

      font-weight: 900;

      background: rgba(255, 255, 255, 0.18);

      padding: 4px 10px;

      border-radius: 999px;

      white-space: nowrap;

    }



    .timer-card {
      position: relative;
      display: flex;
      flex-direction: column;
      gap: 8px;
      margin-top: 0;
      overflow: hidden;
      min-height: 220px;
      height: 220px;
      background: transparent;
      border: none;
      box-shadow: none;
      padding: 0;
    }




    .timer-title {

      font-size: 12px;

      color: var(--muted);

      letter-spacing: 0.12em;

      text-transform: uppercase;

    }



    .timer-display {

      width: 100%;

      text-align: center;

      font-size: 42px;

      font-weight: 900;

      letter-spacing: 0.08em;

      padding: 0;

      border-radius: 12px;

      background: transparent;

      border: none;

      color: var(--text);

    }



    .timer-surface {

      height: 100%;

      padding: 0;

      background: transparent;

      border: none;

      box-shadow: none;

    }



    .panel-range {

      font-size: 12px;

      color: var(--muted);

      text-align: left;

    }



    .panel-row {

      display: flex;

      align-items: flex-start;

      justify-content: space-between;

      gap: 18px;

      width: 100%;

      min-height: 0;

      padding: 0 60px;

    }



    .panel-time {

      text-align: left;

    }



    .panel-time .countdown,

    .panel-time .timer-display {

      font-size: var(--countdownSize);

      line-height: var(--countdownLine);

      background: transparent;

      padding: 0;

      text-align: left;

      width: auto;

    }



    .panel-sub {

      font-size: 11px;

      letter-spacing: 0.14em;

      text-transform: uppercase;

      color: var(--muted);

      margin-top: 6px;

      text-align: left;

    }



    .panel-cta {

      border: none;

      border-radius: 12px;

      padding: 0 34px;

      font-weight: 800;

      background: var(--primary);

      color: #fff;

      cursor: pointer;

      display: inline-flex;

      flex-direction: column;

      align-items: center;

      justify-content: center;

      width: 260px;

      height: var(--countdownLine);

      position: relative;

      text-align: left;

      transition: transform 160ms var(--ease), filter 160ms var(--ease);

    }



    .panel-cta:hover {

      transform: translateY(-1px);

      filter: brightness(1.08);

    }



    .panel-cta:disabled {

      opacity: 0.5;

      cursor: not-allowed;

      transform: none;

      filter: none;

    }



    .panel-cta-text {

      font-size: 24px;

      letter-spacing: 0.06em;

      text-transform: uppercase;

      align-self: center;

      text-align: center;

      line-height: 1;

    }



    .panel-cta-sub {

      font-size: 10px;

      opacity: 0.85;

      position: absolute;

      right: 12px;

      bottom: 8px;

      text-align: right;

    }



    .panel-cta:not(.is-locked) .panel-cta-sub {

      display: none;

    }



    .panel-task {

      font-size: 12px;

      color: var(--muted);

      text-align: right;

      align-self: flex-end;

      padding-bottom: 2px;

    }



    .panel-task span {

      color: var(--text);

    }



    .lockin-panel {
      position: relative;
      height: 100%;
      display: grid;
      grid-template-rows: auto 1fr auto;
      gap: 14px;
      padding: 16px 20px;
      border-radius: 12px;
      background: color-mix(in srgb, var(--card) 88%, var(--primary) 12%);
      border: 1px solid color-mix(in srgb, var(--border) 70%, var(--primary) 30%);
      box-shadow: none;
    }


    .lockin-range {

      font-size: 12px;

      color: var(--muted);

      text-align: left;

    }

    .lockin-top {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
    }

    .lockin-history-btn {
      border: 1px solid var(--border);
      background: transparent;
      color: var(--muted);
      font-size: 10px;
      letter-spacing: 0.14em;
      text-transform: uppercase;
      padding: 4px 10px;
      border-radius: 999px;
      cursor: pointer;
      transition: color 160ms var(--ease), border-color 160ms var(--ease), background 160ms var(--ease);
    }

    .lockin-history-btn:hover {
      color: var(--text);
      border-color: color-mix(in srgb, var(--border) 70%, white 30%);
      background: rgba(255, 255, 255, 0.06);
    }



    .lockin-row {
      display: grid;
      grid-template-columns: 1fr auto;
      align-items: center;
      gap: 18px;
      width: 100%;
      min-height: 0;
      padding: 0 44px;
    }


    .lockin-left {

      text-align: left;

    }



    .lockin-time {

      font-size: clamp(44px, 6vw, 64px);

      line-height: 1;

      font-weight: 900;

      letter-spacing: 0.04em;

      color: var(--text);

      background: transparent;

      padding: 0;

      text-align: left;

      width: auto;

    }



    .lockin-sub {

      font-size: 11px;

      letter-spacing: 0.14em;

      text-transform: uppercase;

      color: var(--muted);

      margin-top: 8px;

      text-align: left;

    }



    .lockin-cta {
      border: none;
      border-radius: 10px;
      padding: 0 24px;
      font-weight: 800;
      background: var(--primary);
      color: #fff;
      cursor: pointer;
      display: inline-flex;

      flex-direction: column;

      align-items: center;

      justify-content: center;

      width: clamp(180px, 28vw, 260px);

      height: 84px;

      position: relative;

      text-align: center;

      transition: transform 160ms var(--ease), filter 160ms var(--ease);

    }



    .lockin-cta:hover {

      transform: translateY(-1px);

      filter: brightness(1.08);

    }



    .lockin-cta:disabled {

      opacity: 0.5;

      cursor: not-allowed;

      transform: none;

      filter: none;

    }



    .lockin-cta.is-locked {
      background: #4aa36f;
      box-shadow: 0 0 0 2px color-mix(in srgb, #4aa36f 60%, transparent);
    }

    .lockin-panel.is-locked {
      background: color-mix(in srgb, var(--card) 80%, #4aa36f 20%);
      border: 1px solid color-mix(in srgb, #4aa36f 45%, var(--border));
    }


    .lockin-cta-text {

      font-size: 24px;

      letter-spacing: 0.08em;

      text-transform: uppercase;

      line-height: 1;

    }



    .lockin-cta-sub {

      font-size: 10px;

      opacity: 0.85;

      position: absolute;

      right: 12px;

      bottom: 10px;

      text-align: right;

    }



    .lockin-cta:not(.is-locked) .lockin-cta-sub {

      display: none;

    }



    .lockin-task {

      font-size: 12px;

      color: var(--muted);

      text-align: right;

      align-self: flex-end;

      padding-bottom: 2px;

    }



    .lockin-task span {

      color: var(--text);

    }



    .timer-meta {

      display: grid;

      gap: 6px;

      font-size: 12px;

      color: var(--muted);

    }



    .timer-meta span {

      color: var(--text);

    }



    .hdr-actions {

      display: flex;

      gap: 8px;

      align-items: center;

      padding: 0;

      border: none;

      background: transparent;

      box-shadow: none;

      justify-self: end;

      grid-column: 3;

    }



    .btn {

      border: none;

      border-radius: 999px;

      width: 32px;

      height: 32px;

      padding: 0;

      cursor: pointer;

      font-weight: 900;

      line-height: 1;

      background: rgba(255, 255, 255, 0.18);

      color: #fff;

      display: inline-flex;

      align-items: center;

      gap: 8px;

      transition: transform 160ms var(--ease), background 160ms var(--ease), box-shadow 160ms var(--ease);

    }



    .hdr-actions .btn {

      width: 36px;

      height: 36px;

      border-radius: 10px;

      background: transparent;

      border: none;

      color: var(--text);

    }



    .hdr-actions .btn:hover {

      transform: none;

      background: transparent;

    }



    .hdr-actions .btn:hover .icon {

      transform: scale(1.25);

    }



    .hdr-actions .btn .icon {

      transition: transform 160ms var(--ease);

    }



    .hdr-actions .btn:active {

      transform: none;

    }



    .btn:disabled {

      opacity: 0.45;

      cursor: not-allowed;

      transform: none;

      box-shadow: none;

    }



    .btn:hover {

      transform: translateY(-1px);

      background: rgba(255, 255, 255, 0.22);

    }



    .btn:focus-visible {

      outline: 2px solid color-mix(in srgb, var(--primary) 60%, transparent);

      outline-offset: 2px;

    }



    .btn:active {

      transform: translateY(0);

      box-shadow: none;

    }



    .accent-btn {

      width: 32px;

      height: 32px;

      position: relative;

    }



    .accent-dot {

      width: 16px;

      height: 16px;

      border-radius: 50%;

      background: var(--primary);

      border: 2px solid rgba(255, 255, 255, 0.75);

      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.25);

    }



    .icon {

      font-size: 26px;

      line-height: 1;

      display: inline-flex;

      align-items: center;

      justify-content: center;

      width: 100%;

      height: 100%;

      transform: translateY(0);

    }



    .wrap {

      height: calc(100vh - var(--headerH));

      max-width: 1200px;

      margin: 0 auto;

      padding: 16px 18px;

      display: grid;

      grid-template-columns: 300px 1fr;

      gap: 14px;

      overflow: hidden;

    }



    .col {

      min-height: 0;

      display: flex;

      flex-direction: column;

      gap: 12px;

    }



    .col.left,

    .col.right {

      overflow: auto;

      padding-right: 2px;

    }



    .card {

      background: var(--card);

      border-radius: var(--radius);

      padding: 12px;

      box-shadow: var(--shadow);

      border: 1px solid var(--border-soft);

      background-image: none;

    }



    /* Calendar */

    .cal-head {

      display: flex;

      align-items: center;

      justify-content: space-between;

      margin-bottom: 8px;

      gap: 8px;

    }



    .cal-title {

      font-weight: 900;

      font-size: 14px;

    }



    .cal-nav {

      display: flex;

      gap: 8px;

    }



    .iconbtn {

      border: 1px solid var(--border);

      background: transparent;

      color: var(--text);

      border-radius: 10px;

      padding: 5px 10px;

      cursor: pointer;

      font-weight: 900;

    }



    .dow {

      display: grid;

      grid-template-columns: repeat(7, 1fr);

      gap: 4px;

      font-size: 11px;

      color: var(--muted);

      margin-bottom: 6px;

      user-select: none;

    }



    .dow div {

      text-align: center;

      padding: 2px 0;

    }



    .cal-grid {

      display: grid;

      grid-template-columns: repeat(7, 1fr);

      gap: 4px;

    }



    .day {

      text-align: center;

      padding: 7px 0;

      border-radius: 10px;

      cursor: pointer;

      user-select: none;

      border: 1px solid transparent;

      font-size: 12px;

    }



    .day:hover {

      border-color: var(--border);

    }



    .day.blank {

      cursor: default;

      opacity: 0;

      pointer-events: none;

    }



    .day.past {

      color: var(--muted);

      opacity: 0.75;

    }



    .day.active {

      background: var(--primary);

      color: #fff;

    }



    .day.today {

      box-shadow: inset 0 0 0 2px color-mix(in srgb, var(--primary) 55%, transparent);

    }



    /* To-do */

    .todo-card {

      padding: 12px;

    }



    .todo-header {

      display: flex;

      align-items: baseline;

      justify-content: space-between;

      margin-bottom: 8px;

    }



    .todo-title {

      font-weight: 900;

      margin: 0;

      font-size: 17px;

      letter-spacing: -0.01em;

    }



    .todo-count {

      font-size: 11px;

      color: var(--muted);

      border: 1px solid var(--border);

      padding: 2px 8px;

      border-radius: 999px;

      min-width: 36px;

      text-align: center;

    }



    .todo-meta {

      display: inline-flex;

      align-items: center;

      gap: 6px;

    }



    .todo-undo {

      border: 1px solid var(--border);

      background: transparent;

      color: var(--text);

      border-radius: 10px;

      padding: 4px 10px;

      font-size: 12px;

      font-weight: 700;

      cursor: pointer;

      display: none;

    }



    .todo-undo.show {

      display: inline-flex;

      align-items: center;

      gap: 6px;

    }



    .todo-input-wrap {

      display: flex;

      align-items: center;

      gap: 8px;

      border: 1px solid var(--border);

      border-radius: 10px;

      padding: 4px 10px;

      background: var(--surface);

      margin-bottom: 8px;

      min-height: 32px;

    }



    .todo-input {

      width: 100%;

      border: none;

      padding: 0;

      background: transparent;

      color: var(--text);

      outline: none;

      margin: 0;

      font-size: 13px;

    }



    .todo-input-wrap:focus-within {

      border-color: var(--focus);

      box-shadow: 0 0 0 3px rgba(80, 160, 255, 0.18);

    }



    .todo-return {

      width: 22px;

      height: 22px;

      display: inline-flex;

      align-items: center;

      justify-content: center;

      background: none;

      border: none;

      background-image: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='18' height='18' viewBox='0 0 24 24' fill='none' stroke='%239a9a9a' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'><path d='M20 4v7a4 4 0 0 1-4 4H5'/><polyline points='9 11 5 15 9 19'/></svg>");

      background-repeat: no-repeat;

      background-position: center;

      background-size: 16px 16px;

      opacity: 0;

      pointer-events: none;

      transition: opacity 160ms var(--ease);

    }



    .todo-input-wrap:focus-within .todo-return {

      opacity: 0.7;

    }



    .todo-list {

      min-height: 100px;

      border: none;

      border-radius: 0;

      padding: 2px 0 4px;

      display: flex;

      flex-direction: column;

      gap: 6px;

      background: none;

    }



    .item {

      display: grid;

      grid-template-columns: 20px 1fr 18px 18px 18px;

      align-items: center;

      gap: 8px;

      padding: var(--itemPad);

      border: 1px solid var(--border);

      border-radius: 10px;

      margin: 0;

      background: var(--surface);

      transition: transform 220ms var(--ease-smooth), background 160ms var(--ease), border-color 160ms var(--ease), box-shadow 220ms var(--ease-smooth);

      min-height: 32px;

      position: relative;

    }



    .item.parent-color {

      background: color-mix(in srgb, var(--surface) 70%, var(--parentTint));

      border-color: color-mix(in srgb, var(--border) 70%, var(--parentBorder));

    }



    body.light .item {

      background: rgba(0, 0, 0, 0.03);

    }



    .item:hover {

      background: var(--surface-strong);

      border-color: color-mix(in srgb, var(--border) 70%, white 30%);

      box-shadow: none;

    }



    .item.child {

      margin-left: 16px;

      padding-left: 12px;

      position: relative;

      background: rgba(255, 255, 255, 0.02);

    }



    .item.child.parent-color {

      background: color-mix(in srgb, var(--surface) 60%, var(--parentTint));

      border-color: color-mix(in srgb, var(--border) 70%, var(--parentBorder));

    }



    .item.child .handle {

      opacity: 1;

      pointer-events: none;

    }



    .item.child .handle::before {

      opacity: 0;

    }



    .item.child .handle::after {

      content: "";

      position: absolute;

      width: 4px;

      height: 4px;

      border-radius: 50%;

      background: var(--muted);

      opacity: 0.7;

    }



    .item.child:hover .handle::after,

    .item.child .handle:hover::after {

      opacity: 0;

    }



    .item.child:hover .handle,

    .item.child .handle:hover {

      pointer-events: auto;

    }



    .item.child:hover .handle::before,

    .item.child .handle:hover::before {

      opacity: 0.9;

    }



    .item.parent-highlight {

      border-color: color-mix(in srgb, var(--primary) 55%, var(--border));

      box-shadow: inset 0 0 0 1px color-mix(in srgb, var(--primary) 45%, transparent);

      background: color-mix(in srgb, var(--surface) 70%, var(--primary) 8%);

    }



    .drag-hidden {

      display: none;

    }



    .item.done .todo-text {

      text-decoration: line-through;

      color: color-mix(in srgb, var(--muted) 70%, var(--text));

      opacity: 0.75;

    }



    .todo-text {

      width: 100%;

      color: var(--text);

      font-size: 13px;

      padding: 0;

      outline: none;

      background: transparent;

      border: none;

      line-height: 1.2;

    }



    .todo-text[contenteditable="true"]:focus {

      outline: none;

    }



    .todo-delete {

      width: 18px;

      height: 18px;

      border-radius: 6px;

      border: none;

      background: transparent;

      color: var(--muted);

      cursor: pointer;

      display: inline-flex;

      align-items: center;

      justify-content: center;

      opacity: 0;

      transition: opacity 160ms var(--ease), color 160ms var(--ease), border-color 160ms var(--ease), background 160ms var(--ease), transform 160ms var(--ease);

      background-image: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 24 24' fill='none' stroke='%239a9a9a' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'><polyline points='3 6 5 6 21 6'/><path d='M19 6l-1 14a2 2 0 0 1-2 2H8a2 2 0 0 1-2-2L5 6'/><path d='M10 11v6'/><path d='M14 11v6'/><path d='M9 6V4a1 1 0 0 1 1-1h4a1 1 0 0 1 1 1v2'/></svg>");

      background-repeat: no-repeat;

      background-position: center;

      background-size: 14px 14px;

    }



    .todo-split {

      width: 18px;

      height: 18px;

      border-radius: 6px;

      border: none;

      background: transparent;

      color: var(--muted);

      cursor: pointer;

      display: inline-flex;

      align-items: center;

      justify-content: center;

      opacity: 0;

      transition: opacity 160ms var(--ease), color 160ms var(--ease), transform 160ms var(--ease);

      background-image: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 24 24' fill='none' stroke='%239a9a9a' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'><line x1='12' y1='5' x2='12' y2='19'/><line x1='5' y1='12' x2='19' y2='12'/></svg>");

      background-repeat: no-repeat;

      background-position: center;

      background-size: 16px 16px;

    }



    .todo-split.is-hidden {

      visibility: hidden;

      pointer-events: none;

    }



    .item:hover .todo-delete,

    .todo-delete:hover,

    .todo-delete:focus-visible {

      opacity: 1;

    }



    .item:hover .todo-split,

    .todo-split:hover,

    .todo-split:focus-visible {

      opacity: 1;

    }



    .todo-delete:hover {

      color: var(--text);

      border-color: color-mix(in srgb, var(--border) 60%, white 40%);

      background-color: transparent;

      transform: scale(1.25);

    }



    .todo-split:hover {

      color: var(--text);

      transform: scale(1.25);

    }



    .tick-btn {

      width: 18px;

      height: 18px;

      border: none;

      background: transparent;

      cursor: pointer;

      opacity: 0;

      pointer-events: none;

      transition: opacity 160ms var(--ease), transform 160ms var(--ease);

      justify-self: end;

      background-image: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='16' height='16' viewBox='0 0 24 24' fill='none' stroke='%239a9a9a' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'><polyline points='20 6 9 17 4 12'/></svg>");

      background-repeat: no-repeat;

      background-position: center;

      background-size: 16px 16px;

    }



    .item:hover .tick-btn,

    .row:hover .tick-btn,

    .tick-btn:focus-visible {

      opacity: 1;

      pointer-events: auto;

    }



    .item.done .tick-btn,

    .row.done .tick-btn {

      opacity: 1;

      pointer-events: auto;

      background-image: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='16' height='16' viewBox='0 0 24 24' fill='none' stroke='%23ffffff' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'><polyline points='20 6 9 17 4 12'/></svg>");

    }



    .handle {

      width: 20px;

      height: 20px;

      display: flex;

      justify-content: center;

      align-items: center;

      color: var(--handle);

      cursor: grab;

      user-select: none;

      font-weight: 900;

      flex: 0 0 20px;

      border-radius: 8px;

      opacity: 0;

      pointer-events: none;

      align-self: center;

      transition: background 160ms var(--ease), transform 180ms var(--ease-snap), opacity 160ms var(--ease);

      transform: translateY(0);

    }



    .handle::before {

      content: "";

      width: 12px;

      height: 16px;

      display: block;

      background-image: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='12' height='16' viewBox='0 0 12 16' fill='%239a9a9a'><circle cx='3' cy='3' r='1.5'/><circle cx='3' cy='8' r='1.5'/><circle cx='3' cy='13' r='1.5'/><circle cx='9' cy='3' r='1.5'/><circle cx='9' cy='8' r='1.5'/><circle cx='9' cy='13' r='1.5'/></svg>");

      background-repeat: no-repeat;

      background-position: center;

      opacity: 0.9;

    }



    .item:hover .handle,

    .row:hover .handle,

    .handle:focus-visible {

      opacity: 1;

      pointer-events: auto;

      transform: translateY(-0.5px);

    }



    .handle:active {

      cursor: grabbing;

    }



    .item.dragging {

      opacity: 1 !important;

      transform: scale(1.02) translateZ(0);

      box-shadow: var(--lift);

    }



    .row.dragging {

      opacity: 1 !important;

      transform: scale(1.01) translateZ(0);

      box-shadow: var(--lift);

    }



    .drag-source {

      opacity: 0.35;

    }





    .row.release,

    .item.release {

      transition: transform 380ms var(--ease-smooth);

      transform: translateY(0);

    }



    .dropzone {

      height: var(--dzH);

      border-radius: 10px;

      margin: 0;

      position: relative;

      transition: height 140ms var(--ease), transform 140ms var(--ease);

      pointer-events: none;

    }



    .dropzone.active {

      height: calc(var(--dzH) + 10px);

      transform: scaleY(1.02);

    }



    .todo-list .dropzone {

      height: 6px;

    }



    .todo-list .dropzone.active {

      height: 10px;

    }



    .dropzone.active::after {

      content: none;

    }



    .drag-ghost {

      position: fixed;

      top: 0;

      left: 0;

      pointer-events: none;

      z-index: 9999;

      transform: translate3d(0, 0, 0);

      box-shadow: var(--lift);

      overflow: visible;

      transition: transform 90ms linear, box-shadow 160ms var(--ease);

    }



    .drag-ghost.ghost-row {

      display: grid;

      grid-template-columns: 66px 20px 1fr 18px;

      align-items: center;

      gap: 8px;

      padding: var(--rowPad);

      border: 1px solid var(--border);

      border-radius: 10px;

      background: rgba(255, 255, 255, 0.04);

    }



    .todo-ghost {

      height: var(--rowH);

      padding: var(--itemPad);

      display: grid;

      grid-template-columns: 56px 1fr;

      align-items: center;

      gap: 8px;

      border-radius: 10px;

      border: 1px solid var(--border);

      background: var(--surface);

      color: var(--text);

      font-size: 13px;

      max-width: 380px;

      white-space: nowrap;

      overflow: hidden;

      text-overflow: ellipsis;

    }



    .todo-ghost-time {

      justify-self: start;

      font-size: 11px;

      color: var(--muted);

      border: 1px solid var(--border);

      border-radius: 999px;

      padding: 2px 6px;

      min-width: 48px;

      text-align: center;

      font-variant-numeric: tabular-nums;

    }



    .todo-ghost-time.is-empty {

      opacity: 0;

      border-color: transparent;

    }



    .todo-ghost-text {

      overflow: hidden;

      text-overflow: ellipsis;

    }





    .drag-ghost.ghost-row .ghost-text {

      font-size: 13px;

      color: var(--text);

      white-space: nowrap;

      overflow: hidden;

      text-overflow: ellipsis;

    }



    .drag-placeholder {

      height: var(--dragGap, 32px);

      border: none;

      border-radius: 10px;

      background: transparent;

      margin: 0;

      box-sizing: border-box;

    }



    .row.insert-gap {

      margin-top: 0;

      transform: translateY(0);

    }



    /* Schedule */

    .sched-head {

      display: flex;

      align-items: baseline;

      justify-content: space-between;

      margin-bottom: 10px;

      gap: 10px;

    }



    .sched-title {

      font-weight: 950;

      margin: 0;

      font-size: 14px;

      letter-spacing: -0.01em;

    }



    .sched-sub {

      color: var(--muted);

      font-size: 11px;

    }



    .blocks {

      position: relative;

      border: 1px solid var(--border);

      border-radius: 12px;

      overflow: hidden;

      background: linear-gradient(to bottom, rgba(255, 255, 255, 0.02), rgba(255, 255, 255, 0.01));

    }



    .row {

      height: var(--rowH);

      display: grid;

      grid-template-columns: 38px 20px 1fr auto;

      align-items: center;

      border-bottom: 1px solid var(--border);

      padding: var(--rowPad);
      gap: 0;

      background: transparent;

      transition: background 160ms var(--ease), border-color 160ms var(--ease), transform 220ms var(--ease-smooth), margin-top 220ms var(--ease-smooth);

    }



    .row.locked {

      background: transparent;

    }



    .row.locked .editor {

      background: transparent;

    }



    .row.parent-color .editor {

      background: color-mix(in srgb, transparent 70%, var(--parentTint));

      border-color: transparent;

    }



    .row.parent-color:hover .editor {

      background: color-mix(in srgb, transparent 60%, var(--parentTint));

      border-color: transparent;

    }



    .row:last-child {

      border-bottom: none;

    }



    .row.past {

      opacity: 1;

    }



    .time {

      color: var(--muted);

      font-size: 12px;

      font-variant-numeric: tabular-nums;

      user-select: none;

    }



    .editor {

      height: calc(var(--rowH) - 8px);

      width: 100%;

      border: 1px solid transparent;

      border-radius: 10px;

      padding: 6px 8px;

      background: transparent;

      color: var(--text);

      outline: none;

      font-size: 13px;

      line-height: 1.2;

    }



    .editor::placeholder {

      color: var(--muted);

    }



    .editor:focus {

      border-color: var(--focus);

      box-shadow: 0 0 0 3px rgba(80, 160, 255, 0.18);

      background: rgba(255, 255, 255, 0.04);

    }



    body.light .editor:focus {

      background: rgba(0, 0, 0, 0.03);

    }



    .droptarget {

      outline: 2px solid rgba(90, 180, 255, 0.55);

      outline-offset: -2px;

      background: rgba(90, 180, 255, 0.08);

      transform: scale(1.01);

    }



    .row:hover {

      background: rgba(255, 255, 255, 0.045);

      box-shadow: inset 0 -1px 0 rgba(255, 255, 255, 0.03);

    }



    .row.done .editor {

      text-decoration: line-through;

      color: color-mix(in srgb, var(--muted) 70%, var(--text));

      opacity: 0.75;

    }



    .row-actions {

      display: inline-flex;

      align-items: center;

      gap: 6px;

      justify-self: end;

      margin-left: 8px;

      padding-right: 52px;

    }



    .row-delete {

      width: 18px;

      height: 18px;

      border: none;

      background: transparent;

      cursor: pointer;

      opacity: 0;

      transition: opacity 160ms var(--ease), transform 160ms var(--ease);

      background-image: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 24 24' fill='none' stroke='%239a9a9a' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'><polyline points='3 6 5 6 21 6'/><path d='M19 6l-1 14a2 2 0 0 1-2 2H8a2 2 0 0 1-2-2L5 6'/><path d='M10 11v6'/><path d='M14 11v6'/><path d='M9 6V4a1 1 0 0 1 1-1h4a1 1 0 0 1 1 1v2'/></svg>");

      background-repeat: no-repeat;

      background-position: center;

      background-size: 14px 14px;

    }



    .row:hover .row-delete,

    .row-delete:hover,

    .row-delete:focus-visible {

      opacity: 1;

    }



    .row-delete:hover {

      transform: scale(1.25);

    }



    .info-icon {

      width: 16px;

      height: 16px;

      display: inline-flex;

      align-items: center;

      justify-content: center;

      color: var(--muted);

      font-size: 14px;

      line-height: 1;

      opacity: 0;

      pointer-events: none;

      flex: 0 0 16px;

    }



    .row:hover .info-icon {

      opacity: 0.8;

      pointer-events: auto;

    }



    .row.dim {

      opacity: var(--dimOpacity);

    }



    .item.dim {

      opacity: var(--dimOpacity);

    }



    .nowline {

      position: absolute;

      left: 0;

      right: 0;

      height: 2px;

      background: color-mix(in srgb, var(--primary) 60%, transparent);

      opacity: 0.45;

      z-index: 1;

      pointer-events: none;

      box-shadow: none;

    }



    .nowpill {

      position: absolute;

      right: 8px;

      transform: translateY(-50%);

      padding: 3px 8px;

      border-radius: 999px;

      background: var(--card);

      border: 1px solid color-mix(in srgb, var(--primary) 55%, var(--border));

      color: var(--primary);

      font-size: 12px;

      font-weight: 950;

      font-variant-numeric: tabular-nums;

      z-index: 6;

      pointer-events: none;

      box-shadow: 0 4px 14px rgba(0, 0, 0, 0.18);

    }



    /* Popovers */

    .backdrop {

      position: fixed;

      inset: 0;

      background: rgba(0, 0, 0, 0.4);

      display: none;

      z-index: 50;

    }



    .popover {

      position: fixed;

      z-index: 60;

      width: 320px;

      background: var(--card);

      border: 1px solid var(--border);

      border-radius: 14px;

      box-shadow: var(--shadow);

      padding: 12px;

      display: none;

    }

    .lock-history-pop {
      width: 420px;
      --lh-pad: 10px;
      --lh-icon: 18px;
      --lh-gap: 10px;
    }

    .lock-history-summary {
      display: grid;
      gap: 4px;
      font-size: 12px;
      color: var(--muted);
      padding: 0 var(--lh-pad);
    }

    .lock-history-summary-text {
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.12em;
      color: var(--muted);
      padding-left: 2px;
    }

    .lock-history-summary-bar {
      position: relative;
      height: 10px;
      border-radius: 999px;
      background: color-mix(in srgb, var(--border) 70%, transparent);
      overflow: hidden;
    }

    .lock-history-summary-fill {
      height: 100%;
      width: 0%;
      background: var(--primary);
      transition: width 200ms var(--ease);
    }

    .lock-history-summary-labels {
      display: grid;
      grid-template-columns: 1fr auto;
      align-items: center;
      column-gap: 10px;
      font-size: 11px;
      color: var(--text);
      margin-top: 4px;
      width: 100%;
      padding-right: 28px;
    }

    .lock-history-goal-cell {
      grid-column: 2 / 3;
      justify-self: end;
      display: inline-flex;
      align-items: center;
      gap: 6px;
    }

    

    .lock-history-goal-link {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      border: none;
      background: transparent;
      color: var(--text);
      font-size: 11px;
      cursor: pointer;
      padding: 0;
    }

    .lock-history-goal-link span:first-child {
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: 0.12em;
      font-size: 10px;
    }

    .lock-history-goal-link::after {
      content: "";
      width: 12px;
      height: 12px;
      margin-left: 4px;
      background-image: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 24 24' fill='none' stroke='%239a9a9a' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'><path d='M12 20h9'/><path d='M16.5 3.5a2.121 2.121 0 1 1 3 3L7 19l-4 1 1-4 12.5-12.5z'/></svg>");
      background-repeat: no-repeat;
      background-position: center;
      background-size: 12px 12px;
      opacity: 0.6;
    }

    .lock-history-goal-link:hover::after {
      opacity: 1;
    }

    .lock-history-divider {
      height: 1px;
      background: var(--border);
      margin-top: 6px;
    }

    .lock-history-panel {
      border: none;
      border-radius: 0;
      padding: 0;
      background: transparent;
      margin-top: 6px;
      display: grid;
      gap: 8px;
    }

    .lock-history-header {
      display: grid;
      grid-template-columns: 1fr;
      align-items: center;
      gap: 10px;
      padding: 0 var(--lh-pad);
    }

    .lock-history-field {
      display: grid;
      gap: 6px;
      font-size: 11px;
      color: var(--muted);
    }

    .lock-history-field input {
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 6px 8px;
      background: transparent;
      color: var(--text);
      width: 100%;
    }

    .lock-history-field input:focus {
      outline: none;
      border-color: var(--focus);
    }

    .lock-history-goal-input {
      display: none;
    }

    .lock-history-goal-input-inline {
      display: none;
      width: 86px;
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 4px 6px;
      background: transparent;
      color: var(--text);
      font-size: 11px;
      text-align: right;
    }

    .lock-history-panel.is-editing .lock-history-goal-link {
      display: none;
    }

    .lock-history-panel.is-editing .lock-history-goal-input-inline {
      display: inline-flex;
    }


    .lock-history-body {
      display: grid;
      gap: 10px;
      margin-top: 6px;
    }

    .lock-history-empty {
      color: var(--muted);
      font-size: 12px;
    }

    .lock-history-list {
      display: grid;
      gap: 10px;
      max-height: 320px;
      overflow: auto;
      padding-right: 4px;
    }

    .lock-history-item {
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 8px var(--lh-pad);
      background: var(--surface);
      display: grid;
      gap: 6px;
    }

    .lock-history-compact {
      display: grid;
      grid-template-columns: 1fr auto var(--lh-icon) var(--lh-icon);
      column-gap: var(--lh-gap);
      row-gap: 4px;
      align-items: center;
    }

    .lock-history-main {
      display: grid;
      gap: 2px;
      font-size: 12px;
    }

    .lock-history-time {
      color: var(--text);
      font-weight: 700;
      letter-spacing: 0.02em;
    }

    .lock-history-task {
      color: var(--muted);
      font-size: 11px;
    }

    .lock-history-meta {
      font-size: 11px;
      color: var(--muted);
      text-align: right;
    }

    .lock-history-edit {
      display: none;
      border-top: 1px solid var(--border);
      padding-top: 8px;
      gap: 6px;
    }

    .lock-history-item.is-editing .lock-history-edit {
      display: grid;
    }

    .lock-history-delete {
      justify-self: end;
    }

    .lock-history-delete.mini-btn {
      padding: 2px 8px;
      font-size: 10px;
    }

    .lock-history-row {
      display: grid;
      grid-template-columns: 52px 1fr;
      gap: 6px;
      align-items: center;
      font-size: 11px;
      color: var(--muted);
    }

    .lock-history-row input {
      width: 100%;
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 6px 8px;
      background: transparent;
      color: var(--text);
    }

    .lock-history-row input:focus {
      outline: none;
      border-color: var(--focus);
    }

    .lock-history-actions {
      margin-top: 8px;
      justify-content: flex-end;
    }

    .lock-history-btn {
      border: 1px solid var(--border);
      background: transparent;
      color: var(--muted);
      font-size: 10px;
      letter-spacing: 0.12em;
      text-transform: uppercase;
      padding: 4px 8px;
      border-radius: 999px;
      cursor: pointer;
    }

    .lock-history-edit-icon {
      width: 18px;
      height: 18px;
      border: none;
      background: transparent;
      cursor: pointer;
      opacity: 0.8;
      background-image: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 24 24' fill='none' stroke='%239a9a9a' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'><path d='M12 20h9'/><path d='M16.5 3.5a2.121 2.121 0 1 1 3 3L7 19l-4 1 1-4 12.5-12.5z'/></svg>");
      background-repeat: no-repeat;
      background-position: center;
      background-size: 12px 12px;
    }

    .lock-history-edit-icon:hover {
      opacity: 1;
    }

    .lock-history-delete-icon {
      width: 18px;
      height: 18px;
      border: none;
      background: transparent;
      cursor: pointer;
      opacity: 0.8;
      background-image: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 24 24' fill='none' stroke='%239a9a9a' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'><polyline points='3 6 5 6 21 6'/><path d='M19 6l-1 14a2 2 0 0 1-2 2H8a2 2 0 0 1-2-2L5 6'/><path d='M10 11v6'/><path d='M14 11v6'/><path d='M9 6V4a1 1 0 0 1 1-1h4a1 1 0 0 1 1 1v2'/></svg>");
      background-repeat: no-repeat;
      background-position: center;
      background-size: 12px 12px;
    }

    .lock-history-delete-icon:hover {
      opacity: 1;
    }



    #errorToast {

      width: auto;

      max-width: 320px;

      background: #5b1f1f;

      border-color: #7a2b2b;

      color: #ffe5e5;

      padding: 10px 12px;

      font-size: 12px;

      border-radius: 10px;

      box-shadow: none;

      display: none;

      position: fixed;

      top: 70px;

      right: 20px;

      z-index: 80;

    }



    #errorToast.show {

      display: block;

    }



    .info-tooltip {

      position: fixed;

      z-index: 90;

      background: #1f1f1f;

      border: 1px solid var(--border);

      color: var(--text);

      font-size: 11px;

      padding: 4px 8px;

      border-radius: 8px;

      pointer-events: none;

      opacity: 0;

      transform: translateY(-4px);

      transition: opacity 80ms var(--ease), transform 80ms var(--ease);

    }



    .info-tooltip.show {

      opacity: 1;

      transform: translateY(0);

    }



    .pop-title {

      font-weight: 950;

      margin: 0 0 10px 0;

      font-size: 13px;

    }



    .section-title {

      margin: 6px 0 2px;

      font-size: 11px;

      letter-spacing: 0.08em;

      text-transform: uppercase;

      color: color-mix(in srgb, var(--muted) 75%, var(--text));

    }



    .row2 {

      display: flex;

      align-items: center;

      justify-content: space-between;

      gap: 10px;

      margin: 8px 0;

    }



    .label {

      color: var(--muted);

      font-size: 12px;

    }



    .range {

      width: auto;

      min-width: 160px;

      max-width: 320px;

      padding: 8px 22px;

    }



    .pill {

      font-variant-numeric: tabular-nums;

      border: 1px solid var(--border);

      padding: 4px 8px;

      border-radius: 999px;

      font-size: 12px;

      color: var(--text);

      min-width: 74px;

      text-align: center;

    }



    .pill-edit {

      cursor: text;

    }



    .pill-edit[contenteditable="true"] {

      outline: 2px solid color-mix(in srgb, var(--primary) 45%, transparent);

      background: rgba(255, 255, 255, 0.05);

    }



    .preview {

      height: 34px;

      border-radius: 12px;

      border: 1px solid var(--border);

      background: var(--primary);

    }



    .sound-preview {

      display: flex;

      gap: 8px;

      margin-top: 8px;

      flex-wrap: wrap;

    }



    .segmented {

      display: inline-flex;

      gap: 4px;

      padding: 2px;

      border-radius: 10px;

      border: 1px solid var(--border);

      background: rgba(255, 255, 255, 0.02);

    }



    .time-select {

      border: 1px solid var(--border);

      background: #1f1f1f;

      color: var(--text);

      border-radius: 8px;

      padding: 6px 8px;

      font-size: 12px;

      min-width: 84px;

      color-scheme: dark;

    }



    .time-select option {

      background: #1f1f1f;

      color: var(--text);

    }



    .seg-btn {

      border: none;

      background: transparent;

      color: var(--muted);

      padding: 6px 10px;

      border-radius: 8px;

      font-size: 12px;

      cursor: pointer;

      transition: color 160ms var(--ease), background 160ms var(--ease);

    }



    .seg-btn.active {

      color: var(--text);

      background: rgba(255, 255, 255, 0.08);

    }



    .sound-btn {

      border: 1px solid var(--border);

      background: transparent;

      color: var(--text);

      border-radius: 10px;

      padding: 6px 10px;

      font-size: 12px;

      cursor: pointer;

    }



    .sound-btn:hover {

      border-color: color-mix(in srgb, var(--border) 70%, white 30%);

      background: rgba(255, 255, 255, 0.06);

    }



    .toggle {

      display: flex;

      align-items: center;

      gap: 8px;

      font-size: 12px;

      color: var(--text);

      user-select: none;

    }



    .help-list {

      margin: 8px 0 0;

      padding-left: 16px;

      color: var(--muted);

      font-size: 12px;

      line-height: 1.4;

    }



    .help-list li {

      margin: 6px 0;

    }



    .toggle input {

      transform: translateY(1px);

    }



    .help-pop {

      width: 380px;

      max-width: calc(100vw - 24px);

    }



    .help-kicker {

      font-size: 11px;

      text-transform: uppercase;

      letter-spacing: 0.12em;

      color: var(--muted);

      margin: 0 0 6px;

      font-weight: 800;

    }



    .help-text {

      color: var(--muted);

      font-size: 12px;

      line-height: 1.5;

      margin: 0 0 12px;

    }



    .help-section {

      border-top: 1px solid var(--border);

      padding-top: 10px;

      margin-top: 10px;

    }



    .help-grid {

      display: grid;

      gap: 8px;

      margin: 0;

    }



    .help-item {

      display: grid;

      gap: 2px;

      font-size: 12px;

      color: var(--text);

    }



    .help-item span {

      color: var(--muted);

      font-size: 11px;

    }



    .welcome-pop {

      width: 360px;

      max-width: calc(100vw - 24px);

    }



    .welcome-pop .pop-title {

      font-size: 15px;

      margin-bottom: 8px;

    }



    .welcome-text {

      color: var(--muted);

      font-size: 12px;

      line-height: 1.45;

      margin: 0 0 10px;

    }



    .welcome-actions {

      display: flex;

      gap: 8px;

      justify-content: flex-end;

      margin-top: 12px;

    }



    .mini-btn {

      border: 1px solid var(--border);

      background: transparent;

      color: var(--text);

      border-radius: 10px;

      padding: 6px 10px;

      font-size: 12px;

      cursor: pointer;

      font-weight: 700;

    }



    .mini-btn:hover {

      border-color: color-mix(in srgb, var(--border) 70%, white 30%);

      background: rgba(255, 255, 255, 0.06);

    }



    .mini-btn.primary {

      background: var(--primary);

      border-color: transparent;

      color: #fff;

    }



    .divider {

      height: 1px;

      background: var(--border);

      margin: 10px 0;

    }



    .col.left::-webkit-scrollbar,

    .col.right::-webkit-scrollbar {

      width: 10px;

    }



    .col.left::-webkit-scrollbar-thumb,

    .col.right::-webkit-scrollbar-thumb {

      background: rgba(255, 255, 255, 0.12);

      border-radius: 999px;

      border: 2px solid transparent;

      background-clip: padding-box;

    }



    body.light .col.left::-webkit-scrollbar-thumb,

    body.light .col.right::-webkit-scrollbar-thumb {

      background: rgba(0, 0, 0, 0.15);

      background-clip: padding-box;

    }



    @media (max-width: 980px) {

      body {

        overflow: auto;

      }



      .wrap {

        height: auto;

        grid-template-columns: 1fr;

        overflow: visible;

      }



      .col.left,

      .col.right {

        overflow: visible;

      }

    }

  </style>

</head>

<body>

  <header>

    <div class="hdr-left">

      <div class="app-title">Pomoplan</div>

    </div>

    <div class="hdr-actions">

      <button id="themeBtn" class="btn" title="Theme" aria-label="Theme">

        <span class="icon">üé®</span>

      </button>

      <button id="soundBtn" class="btn" title="Sound settings" aria-label="Sound settings">

        <span class="icon">üîä</span>

      </button>

      <button id="settingsBtn" class="btn" title="Schedule settings" aria-label="Schedule settings">

        <span class="icon">‚öôÔ∏è</span>

      </button>

      <button id="helpBtn" class="btn" title="Help" aria-label="Help">

        <span class="icon">‚ùì</span>

      </button>

    </div>

  </header>



  <div class="wrap">

    <div class="col left">

      <div class="card">

        <div class="cal-head">

          <div class="cal-title" id="monthLabel"></div>

          <div class="cal-nav">

            <button class="iconbtn" id="prevMonth" aria-label="Previous month">‚Äπ</button>

            <button class="iconbtn" id="nextMonth" aria-label="Next month">‚Ä∫</button>

          </div>

        </div>



        <div class="dow">

          <div>Su</div><div>Mo</div><div>Tu</div><div>We</div><div>Th</div><div>Fr</div><div>Sa</div>

        </div>



        <div class="cal-grid" id="calGrid"></div>

      </div>

      <div class="card todo-card">

        <div class="todo-header">

          <h3 class="todo-title">To Do</h3>

          <div class="todo-meta">

            <button id="undoBtn" class="todo-undo" type="button">Undo</button>

            <div id="todoCount" class="todo-count">0</div>

          </div>

        </div>

        <div class="todo-input-wrap">

          <input id="todoInput" class="todo-input" placeholder="Add a task..." />

          <span class="todo-return" aria-hidden="true"></span>

        </div>

        <div id="todoList" class="todo-list"></div>

        <div class="label" style="margin-top:6px;">Drag using the handle. Drop between items to reorder.</div>

      </div>

    </div>



    <div class="col right">

      <div class="timer-card">
        <div class="timer-surface">

          <div class="lockin-panel">
            <div class="lockin-top">
              <div id="panelRange" class="lockin-range">--:--</div>
              <button id="lockHistoryBtn" class="lockin-history-btn" type="button">History</button>
            </div>

            <div class="lockin-row">

              <div class="lockin-left">

                <div id="countdown" class="lockin-time timer-display">--:--</div>

                <div class="lockin-sub">Until next task</div>

              </div>

              <button id="lockBtn" class="lockin-cta" type="button">
                <span id="panelCtaText" class="lockin-cta-text">Lock In</span>

                <span id="panelElapsed" class="lockin-cta-sub">00:00</span>

              </button>

            </div>

            <div id="panelTask" class="lockin-task">Task: <span>‚Äî</span></div>

          </div>

        </div>

      </div>

      <div class="card">

        <div class="sched-head">

          <h3 class="sched-title" id="dateLabel"></h3>

        <div id="schedSub" class="sched-sub">7:00 AM - 10:00 PM (30-min blocks)</div>

        </div>



        <div class="blocks" id="blocks">

          <div class="nowline" id="nowLine" style="display:none"></div>

          <div class="nowpill" id="nowPill" style="display:none"></div>

          <div id="rows"></div>

        </div>

      </div>

    </div>

  </div>



  <div id="backdrop" class="backdrop"></div>



  <div id="accentPop" class="popover" role="dialog" aria-label="Theme settings">

    <div class="pop-title">Theme</div>

    <div class="section-title">Mode</div>

    <div class="row2">

      <div class="label">Theme</div>

      <div class="segmented" role="group" aria-label="Theme mode">

        <button id="themeDark" class="seg-btn" type="button">Dark</button>

        <button id="themeLight" class="seg-btn" type="button">Light</button>

      </div>

    </div>

    <div class="divider"></div>

    <div class="section-title">Accent</div>

    <div class="preview" id="accentPreview"></div>



    <div class="row2">

      <div class="label">Hue</div>

      <div class="pill pill-edit" id="hVal" data-range="hRange" data-min="0" data-max="360">246¬∞</div>

    </div>

    <input id="hRange" class="range" type="range" min="0" max="360" value="246" />



    <div class="row2">

      <div class="label">Saturation</div>

      <div class="pill pill-edit" id="sVal" data-range="sRange" data-min="0" data-max="100">48%</div>

    </div>

    <input id="sRange" class="range" type="range" min="0" max="100" value="48" />



    <div class="row2">

      <div class="label">Lightness</div>

      <div class="pill pill-edit" id="lVal" data-range="lRange" data-min="0" data-max="100">25%</div>

    </div>

    <input id="lRange" class="range" type="range" min="0" max="100" value="25" />



    <div class="divider"></div>

    <div class="row2">

      <div class="label">Hex</div>

      <div class="pill" id="hexVal">#27215e</div>

    </div>



    <div class="divider"></div>

    <div class="section-title">Task tint</div>

    <div class="row2">

      <div class="label">Saturation</div>

      <div class="pill pill-edit" id="tintVal" data-range="tintRange" data-min="0" data-max="60">30%</div>

    </div>

    <input id="tintRange" class="range" type="range" min="0" max="60" value="30" />



    <div class="divider"></div>

    <div class="section-title">Focus dimming</div>

    <label class="toggle">

      <input id="dimScheduleChk" type="checkbox" />

      Only dim schedule when child is scheduled

    </label>

    <div class="row2" style="margin-top:10px;">

      <div class="label">Dim strength</div>

      <div class="pill pill-edit" id="dimVal" data-range="dimRange" data-min="0" data-max="100">50%</div>

    </div>

    <input id="dimRange" class="range" type="range" min="0" max="100" value="50" />

  </div>



  <div id="soundPop" class="popover" role="dialog" aria-label="Sound settings">

    <div class="pop-title">Sound settings</div>



    <label class="toggle">

      <input id="muteChk" type="checkbox" />

      Mute

    </label>



    <div class="row2" style="margin-top:10px;">

      <div class="label">Volume</div>

      <div class="pill" id="volVal">60%</div>

    </div>

    <input id="volRange" class="range" type="range" min="0" max="100" value="60" />



    <div class="divider"></div>



    <label class="toggle">

      <input id="onlyIfTaskChk" type="checkbox" />

      Only play sounds when current block has a task

    </label>



    <div class="label" style="margin-top:10px;">

      Plays a warning at 5 minutes remaining and another sound when the block ends.

    </div>



    <div class="row2">

      <div class="label">Preview sounds</div>

    </div>

    <div class="sound-preview">

      <button id="previewWarn" class="sound-btn" type="button">5-min warning</button>

      <button id="previewEnd" class="sound-btn" type="button">Slot end</button>

    </div>

  </div>



  <div id="settingsPop" class="popover" role="dialog" aria-label="Schedule settings">

    <div class="pop-title">Schedule settings</div>

    <div class="row2">

      <div class="label">Start</div>

      <select id="startTime" class="time-select" aria-label="Start time"></select>

    </div>

    <div class="row2">

      <div class="label">End</div>

      <select id="endTime" class="time-select" aria-label="End time"></select>

    </div>

    <div class="divider"></div>

    <div class="row2">

      <div class="label">Schedule blocks</div>

    </div>

    <div class="segmented" role="group" aria-label="Slot length">

      <button id="slot30" class="seg-btn" type="button">30 min</button>

      <button id="slot60" class="seg-btn" type="button">60 min</button>

    </div>

    <div class="divider"></div>

    <div class="row2">
      <div class="label">Daily focus goal (mins)</div>
      <input id="focusGoal" class="time-select" type="number" min="10" step="5" />
    </div>

  </div>

  <div id="lockHistoryPop" class="popover lock-history-pop" role="dialog" aria-label="Time locked in">
    <div class="pop-title">Time locked in</div>
    <div class="lock-history-panel" id="lockHistoryPanel">
      <div class="lock-history-header">
        <label class="lock-history-field lock-history-field-day">
          <input id="lockHistoryDate" type="date" />
        </label>
      </div>
      <div id="lockHistorySummary" class="lock-history-summary"></div>
    </div>
    <div class="lock-history-body">
      <div class="lock-history-empty">No lock sessions yet.</div>
      <div id="lockHistoryList" class="lock-history-list"></div>
    </div>
  </div>

  <div id="helpPop" class="popover help-pop" role="dialog" aria-label="Help">

    <div class="pop-title">Quick help</div>

    <div class="help-kicker">What this is</div>

    <p class="help-text">

      Pomoplan is for time-blocking your day. Add tasks, drag priorities into the schedule,

      and focus on one block at a time with optional sound alerts. If you use Pomodoro,

      treat each block as a focused sprint (often 25 minutes work + a short break).

    </p>



    <div class="help-section">

      <div class="help-kicker">Core actions</div>

      <div class="help-grid">

        <div class="help-item">

          Type a task in any time slot.

          <span>Press Enter to save.</span>

        </div>

        <div class="help-item">

          Drag by the handle to reorder or move items.

          <span>Between To Do and Schedule.</span>

        </div>

        <div class="help-item">

          Check off completed items.

          <span>Hover to reveal checkboxes and delete.</span>

        </div>

      </div>

    </div>



    <div class="help-section">

      <div class="help-kicker">Customize</div>

      <div class="help-grid">

        <div class="help-item">

          Schedule range and block size.

          <span>30 or 60 minute blocks.</span>

        </div>

        <div class="help-item">

          Sound alerts and previews.

          <span>5‚Äëminute warning + end of block.</span>

        </div>

        <div class="help-item">

          Theme + accent color.

          <span>Use the buttons in the top-right.</span>

        </div>

      </div>

    </div>

  </div>

  <div id="errorToast" class="popover" role="status" aria-live="polite"></div>

  <div id="infoTip" class="info-tooltip" role="status" aria-live="polite"></div>



  <div id="welcomePop" class="popover welcome-pop" role="dialog" aria-label="Welcome">

    <div class="pop-title">Welcome to Pomoplan</div>

    <p class="welcome-text">

      This app is built for time-blocking your day. Add tasks, drag your priorities into

      the schedule, and focus on one block at a time. Check items off as you go and use

      sound alerts to stay on track.

    </p>

    <ul class="help-list">

      <li>Plan your day in 30 or 60 minute blocks.</li>

      <li>Move tasks between To Do and the schedule by dragging.</li>

      <li>Use the top-right buttons for settings, sound, and quick help.</li>

    </ul>

    <div class="welcome-actions">

      <button id="welcomeHelpBtn" class="mini-btn" type="button">Show help</button>

      <button id="welcomeCloseBtn" class="mini-btn primary" type="button">Get started</button>

    </div>

  </div>

  <script>

    const $ = (sel, root = document) => root.querySelector(sel);

    const $$ = (sel, root = document) => Array.from(root.querySelectorAll(sel));



    function clamp(n, a, b) {

      return Math.max(a, Math.min(b, n));

    }



    function safeParse(s) {

      try {

        return JSON.parse(s);

      } catch {

        return null;

      }

    }



    function dateKey(d) {

      const y = d.getFullYear();

      const m = String(d.getMonth() + 1).padStart(2, "0");

      const day = String(d.getDate()).padStart(2, "0");

      return `${y}-${m}-${day}`;

    }



    function isSameDay(a, b) {

      return a.getFullYear() === b.getFullYear() && a.getMonth() === b.getMonth() && a.getDate() === b.getDate();

    }



    function isPastDay(d, today) {

      const a = new Date(d.getFullYear(), d.getMonth(), d.getDate()).getTime();

      const b = new Date(today.getFullYear(), today.getMonth(), today.getDate()).getTime();

      return a < b;

    }



    let START_H = 7;

    let END_H = 22;

    let SLOT_MIN = 30;



    function timeString(h, m) {

      return `${String(h).padStart(2, "0")}:${String(m).padStart(2, "0")}`;

    }



    function allTimes(slotMin) {

      const out = [];

      for (let h = START_H; h < END_H; h += 1) {

        out.push(timeString(h, 0));

        if (slotMin === 30) out.push(timeString(h, 30));

      }

      return out;

    }



    let TIMES = allTimes(SLOT_MIN);



    function isPastTimeSlot(slotDate, tStr) {

      const today = new Date();

      if (!isSameDay(slotDate, today)) return false;

      const [hh, mm] = tStr.split(":").map(Number);

      const t = new Date(slotDate.getFullYear(), slotDate.getMonth(), slotDate.getDate(), hh, mm, 0, 0);

      return t.getTime() < Date.now();

    }



    function getCurrentBlockInfo(now = new Date()) {

      const mins = now.getHours() * 60 + now.getMinutes();

      const startM = START_H * 60;

      const endM = END_H * 60;

      if (mins < startM || mins >= endM) return null;



      const minsInto = mins - startM;

      const slotIndex = Math.floor(minsInto / SLOT_MIN);

      const slotStartMins = startM + slotIndex * SLOT_MIN;

      const slotEndMins = slotStartMins + SLOT_MIN;

      const remainingMins = slotEndMins - mins;



      const startH = Math.floor(slotStartMins / 60);

      const startMin = slotStartMins % 60;

      const timeKey = timeString(startH, startMin);



      return {

        slotIndex,

        timeKey,

        slotStartMins,

        slotEndMins,

        remainingMins,

        remainingSecs: slotEndMins * 60 - (now.getHours() * 3600 + now.getMinutes() * 60 + now.getSeconds())

      };

    }



    function hslToRgb(h, s, l) {

      s /= 100;

      l /= 100;

      const c = (1 - Math.abs(2 * l - 1)) * s;

      const x = c * (1 - Math.abs((h / 60) % 2 - 1));

      const m = l - c / 2;

      let r = 0;

      let g = 0;

      let b = 0;

      if (h >= 0 && h < 60) {

        r = c;

        g = x;

      } else if (h < 120) {

        r = x;

        g = c;

      } else if (h < 180) {

        g = c;

        b = x;

      } else if (h < 240) {

        g = x;

        b = c;

      } else if (h < 300) {

        r = x;

        b = c;

      } else {

        r = c;

        b = x;

      }

      return {

        r: Math.round((r + m) * 255),

        g: Math.round((g + m) * 255),

        b: Math.round((b + m) * 255)

      };

    }



    function rgbToHex(r, g, b) {

      const to = (n) => n.toString(16).padStart(2, "0");

      return `#${to(r)}${to(g)}${to(b)}`;

    }



    function hslToHex(h, s, l) {

      const { r, g, b } = hslToRgb(h, s, l);

      return rgbToHex(r, g, b);

    }



    function hexToRgb(hex) {

      const m = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);

      if (!m) return null;

      return { r: parseInt(m[1], 16), g: parseInt(m[2], 16), b: parseInt(m[3], 16) };

    }



    function rgbToHsl(r, g, b) {

      r /= 255;

      g /= 255;

      b /= 255;

      const max = Math.max(r, g, b);

      const min = Math.min(r, g, b);

      let h = 0;

      let s = 0;

      const l = (max + min) / 2;

      const d = max - min;

      if (d !== 0) {

        s = d / (1 - Math.abs(2 * l - 1));

        switch (max) {

          case r:

            h = 60 * (((g - b) / d) % 6);

            break;

          case g:

            h = 60 * ((b - r) / d + 2);

            break;

          case b:

            h = 60 * ((r - g) / d + 4);

            break;

          default:

            break;

        }

      }

      if (h < 0) h += 360;

      return { h: Math.round(h), s: Math.round(s * 100), l: Math.round(l * 100) };

    }



    const STORE_KEY = "dailyScheduler_v5";

    const WELCOME_KEY = "dailyScheduler_seenWelcome_v1";

    const defaultState = {

      settings: {

        theme: "dark",

        accent: "#27215e",

        accentHSL: { h: 246, s: 48, l: 25 },

        taskTintSat: 30,

        dimOpacity: 50,

        dimScheduleOnlyWhenChild: true,

        focusTargetMins: 120,

        slotMinutes: 30,

        dayStart: 7,

        dayEnd: 22,

        sound: {

          mute: false,

          volume: 60,

          onlyIfTask: true

        }

      },

      blockLocks: {},

      activeLock: null,

      lockHistory: [],

      todos: [],

      schedules: {}

    };



    function makeId() {

      return `id_${Date.now()}_${Math.random().toString(16).slice(2, 8)}`;

    }



    let parentHueMap = new Map();

    let parentHueSignature = "";



    function collectParentIds() {

      const ids = new Set();

      state.todos.forEach((todo) => {

        if (isParentTodo(todo)) ids.add(todo.id);

        if (todo.parentId) ids.add(todo.parentId);

      });

      Object.values(state.schedules || {}).forEach((day) => {

        if (!day || typeof day !== "object") return;

        Object.values(day).forEach((item) => {

          if (item?.parentId) ids.add(item.parentId);

        });

      });

      return [...ids];

    }



    function ensureParentHueMap() {

      const ids = collectParentIds().sort();

      const signature = ids.join("|");

      if (signature === parentHueSignature) return;

      parentHueSignature = signature;

      parentHueMap = new Map();

      if (!ids.length) return;

      const step = 360 / ids.length;

      ids.forEach((id, idx) => {

        const hue = Math.round((idx * step) % 360);

        parentHueMap.set(id, hue);

      });

    }



    function getParentColors(parentId) {

      if (!parentId) return null;

      ensureParentHueMap();

      const hue = parentHueMap.get(parentId);

      if (hue == null) return null;

      const sat = clamp(state.settings.taskTintSat ?? 30, 0, 100);

      const borderSat = clamp(sat + 2, 0, 100);

      return {

        tint: `hsl(${hue} ${sat}% 28%)`,

        border: `hsl(${hue} ${borderSat}% 40%)`

      };

    }



    function normalizeTodo(entry) {

      if (!entry) return null;

      if (typeof entry === "string") return { id: makeId(), text: entry, done: false };

      if (typeof entry === "object") {

        return {

          id: entry.id || makeId(),

          text: entry.text ?? "",

          done: !!entry.done,

          parentId: entry.parentId ?? null,

          parentName: entry.parentName ?? null

        };

      }

      return null;

    }



    function normalizeScheduleItem(entry) {

      if (!entry) return null;

      if (typeof entry === "string") return { id: makeId(), text: entry, done: false };

      if (typeof entry === "object") {

        return {

          id: entry.id || makeId(),

          text: entry.text ?? "",

          done: !!entry.done,

          parentId: entry.parentId ?? null,

          parentName: entry.parentName ?? null

        };

      }

      return null;

    }



    let state = safeParse(localStorage.getItem(STORE_KEY)) ?? structuredClone(defaultState);



    function normalizeState() {

      const baseSettings = structuredClone(defaultState.settings);

      state.settings = { ...baseSettings, ...(state.settings ?? {}) };

      state.settings.sound = { ...baseSettings.sound, ...(state.settings.sound ?? {}) };

      state.settings.accentHSL = state.settings.accentHSL ?? structuredClone(baseSettings.accentHSL);

      state.settings.slotMinutes = state.settings.slotMinutes ?? baseSettings.slotMinutes;

      state.settings.dayStart = state.settings.dayStart ?? baseSettings.dayStart;

      state.settings.dayEnd = state.settings.dayEnd ?? baseSettings.dayEnd;

      state.settings.taskTintSat = state.settings.taskTintSat ?? baseSettings.taskTintSat;

      state.settings.dimOpacity = state.settings.dimOpacity ?? baseSettings.dimOpacity;

      state.settings.dimScheduleOnlyWhenChild = state.settings.dimScheduleOnlyWhenChild ?? baseSettings.dimScheduleOnlyWhenChild;
      state.settings.focusTargetMins = state.settings.focusTargetMins ?? baseSettings.focusTargetMins;

      if (!state.blockLocks || typeof state.blockLocks !== "object") state.blockLocks = {};

      Object.keys(state.blockLocks).forEach((k) => {

        const entry = state.blockLocks[k];

        if (entry === true) state.blockLocks[k] = { startedAt: Date.now() };

        if (entry && typeof entry === "object" && typeof entry.startedAt !== "number") {

          state.blockLocks[k] = { startedAt: Date.now() };

        }

      });

      if (!state.activeLock || typeof state.activeLock !== "object") state.activeLock = null;
      if (state.activeLock && typeof state.activeLock.startedAt !== "number") state.activeLock = null;
      if (!Array.isArray(state.lockHistory)) state.lockHistory = [];

      state.todos = Array.isArray(state.todos) ? state.todos.map(normalizeTodo).filter(Boolean) : [];

      if (!state.schedules || typeof state.schedules !== "object") state.schedules = {};

      Object.keys(state.schedules).forEach((dk) => {

        const sched = state.schedules[dk];

        if (!sched || typeof sched !== "object") {

          state.schedules[dk] = {};

          return;

        }

        Object.keys(sched).forEach((t) => {

          const normalized = normalizeScheduleItem(sched[t]);

          if (normalized && normalized.text) sched[t] = normalized;

          else delete sched[t];

        });

      });

    }



    normalizeState();

    START_H = state.settings.dayStart ?? 7;

    END_H = state.settings.dayEnd ?? 22;

    SLOT_MIN = state.settings.slotMinutes ?? 30;

    TIMES = allTimes(SLOT_MIN);

    save();



    function save() {

      localStorage.setItem(STORE_KEY, JSON.stringify(state));

    }



    function ensureSchedule(dk) {

      if (!state.schedules[dk]) state.schedules[dk] = {};

      return state.schedules[dk];

    }



    function getSlotText(dk, t) {

      return state.schedules?.[dk]?.[t]?.text ?? "";

    }



    function getSlotItem(dk, t) {

      return state.schedules?.[dk]?.[t] ?? null;

    }



    function setSlotText(dk, t, text) {

      ensureSchedule(dk);

      const trimmed = text.trim();

      if (!trimmed) {

        delete state.schedules[dk][t];

        return;

      }

      const existing = state.schedules[dk][t];

      if (existing) {

        existing.text = text;

      } else {

        state.schedules[dk][t] = { id: makeId(), text, done: false };

      }

    }



    function setSlotItem(dk, t, item) {

      ensureSchedule(dk);

      if (!item || !item.text || !item.text.trim()) {

        delete state.schedules[dk][t];

        return;

      }

      state.schedules[dk][t] = item;

    }



    function setSlotDone(dk, t, done) {

      const item = getSlotItem(dk, t);

      if (!item) return;

      item.done = !!done;

    }



    function lockKey(dk, t) {

      return `${dk}|${t}`;

    }



    function isBlockLocked(dk, t) {

      return !!state.blockLocks?.[lockKey(dk, t)];

    }



    function getLockInfo(dk, t) {

      const info = state.blockLocks?.[lockKey(dk, t)];

      if (!info) return null;

      if (typeof info === "object" && typeof info.startedAt === "number") return info;

      return { startedAt: Date.now() };

    }



    function setBlockLocked(dk, t, locked) {

      if (!state.blockLocks || typeof state.blockLocks !== "object") state.blockLocks = {};

      const key = lockKey(dk, t);

      if (locked) {

        const existing = state.blockLocks[key];

        if (existing && typeof existing === "object" && typeof existing.startedAt === "number") return;

        state.blockLocks[key] = { startedAt: Date.now() };

      } else {

        delete state.blockLocks[key];

      }

    }



    function applyTheme() {

      document.body.classList.toggle("light", state.settings.theme === "light");

      document.documentElement.style.setProperty("--primary", state.settings.accent);

      const dimStrength = clamp(state.settings.dimOpacity ?? 25, 0, 100);

      const dimOpacity = 1 - dimStrength / 100;

      document.documentElement.style.setProperty("--dimOpacity", String(dimOpacity));

      // theme button uses the accent dot; no per-mode icon swap

    }



    applyTheme();





    const backdrop = $("#backdrop");

    const accentPop = $("#accentPop");

    const soundPop = $("#soundPop");

    const helpPop = $("#helpPop");

    const settingsPop = $("#settingsPop");

    const welcomePop = $("#welcomePop");

    const undoBtn = $("#undoBtn");

    const infoTip = $("#infoTip");

    const slot30Btn = $("#slot30");

    const slot60Btn = $("#slot60");

    const startTimeSel = $("#startTime");

    const endTimeSel = $("#endTime");
    const focusGoalInput = $("#focusGoal");
    const lockHistoryBtn = $("#lockHistoryBtn");
    const lockHistoryPop = $("#lockHistoryPop");
    const lockHistoryList = $("#lockHistoryList");
    const lockHistorySummary = $("#lockHistorySummary");
    const lockHistoryDate = $("#lockHistoryDate");
    const lockHistoryPanel = $("#lockHistoryPanel");

    const themeDarkBtn = $("#themeDark");

    const themeLightBtn = $("#themeLight");

    const welcomeCloseBtn = $("#welcomeCloseBtn");

    const welcomeHelpBtn = $("#welcomeHelpBtn");

    let openPop = null;

    const deletedStack = [];

    let pendingFocusId = null;



    function findTodoById(id) {

      return state.todos.find((t) => t.id === id) || null;

    }



    function isParentTodo(todo) {

      if (!todo) return false;

      const hasTodoChildren = state.todos.some((t) => t.parentId === todo.id);

      if (hasTodoChildren) return true;

      return hasScheduleChildren(todo.id);

    }



    function hasScheduleChildren(parentId) {

      if (!parentId) return false;

      const schedules = state.schedules || {};

      return Object.values(schedules).some((day) => {

        if (!day || typeof day !== "object") return false;

        return Object.values(day).some((item) => item && item.parentId === parentId);

      });

    }



    function getTodoGroupIds(rootId) {

      const ids = new Set();

      const queue = [rootId];

      while (queue.length) {

        const cur = queue.shift();

        if (!cur || ids.has(cur)) continue;

        ids.add(cur);

        state.todos.forEach((t) => {

          if (t.parentId === cur) queue.push(t.id);

        });

      }

      return ids;

    }



    function findInsertIndexForParent(list, parentId, fallbackId) {

      let lastIdx = -1;

      let parentIdx = -1;

      list.forEach((t, i) => {

        if (t.id === parentId) parentIdx = i;

        if (t.parentId === parentId) lastIdx = i;

      });

      const baseIdx = lastIdx !== -1 ? lastIdx : parentIdx;

      if (baseIdx !== -1) return baseIdx + 1;

      if (fallbackId) {

        const hoverIdx = list.findIndex((t) => t.id === fallbackId);

        if (hoverIdx !== -1) return hoverIdx;

      }

      return list.length;

    }



    function showError(msg) {

      const toast = $("#errorToast");

      if (!toast) return;

      toast.textContent = msg;

      toast.classList.add("show");

      clearTimeout(showError._t);

      showError._t = setTimeout(() => toast.classList.remove("show"), 2200);

    }



    function clearAllDim() {

      rowsEl.querySelectorAll(".row").forEach((r) => r.classList.remove("dim"));

      todoList.querySelectorAll(".item").forEach((i) => i.classList.remove("dim"));

    }



    let dimClearTimer = null;



    function scheduleDimClear(delay = 80) {

      if (dimClearTimer) clearTimeout(dimClearTimer);

      dimClearTimer = setTimeout(() => {

        clearAllDim();

        dimClearTimer = null;

      }, delay);

    }



    function cancelDimClear() {

      if (dimClearTimer) {

        clearTimeout(dimClearTimer);

        dimClearTimer = null;

      }

    }



    function applyTodoDim(todo) {

      if (!todo) return;

      cancelDimClear();

      const targetParentId = todo.parentId || todo.id;

      const hasSched = hasScheduleChildren(targetParentId);

      const shouldDimSchedule = !state.settings.dimScheduleOnlyWhenChild || hasSched;

      if (shouldDimSchedule) {

        rowsEl.querySelectorAll(".row").forEach((r) => r.classList.add("dim"));

      } else {

        rowsEl.querySelectorAll(".row").forEach((r) => r.classList.remove("dim"));

      }

      todoList.querySelectorAll(".item").forEach((i) => i.classList.add("dim"));

      const parentItem = todoList.querySelector(`.item[data-todo-id="${targetParentId}"]`);

      if (parentItem) parentItem.classList.remove("dim");

      todoList

        .querySelectorAll(`.item[data-parent-id="${targetParentId}"]`)

        .forEach((i) => i.classList.remove("dim"));

      rowsEl

        .querySelectorAll(`.row[data-parent-id="${targetParentId}"]`)

        .forEach((r) => r.classList.remove("dim"));

    }



    function getHoverTodoIdFromPoint(x, y) {

      const els = document.elementsFromPoint(x, y);

      for (const el of els) {

        const item = el.closest?.(".item");

        const id = item?.dataset?.todoId;

        if (id) return id;

      }

      return null;

    }



    function openPopover(pop, anchorEl) {

      closePopover();

      openPop = pop;

      backdrop.style.display = "block";

      pop.style.display = "block";

      pop.style.transform = "none";



      const r = anchorEl.getBoundingClientRect();

      const popRect = pop.getBoundingClientRect();

      const pad = 10;

      let left = r.right - popRect.width;

      let top = r.bottom + 10;

      left = clamp(left, pad, window.innerWidth - popRect.width - pad);

      top = clamp(top, pad, window.innerHeight - popRect.height - pad);

      pop.style.left = `${left}px`;

      pop.style.top = `${top}px`;

    }



    function openCenteredPopover(pop) {

      closePopover();

      openPop = pop;

      backdrop.style.display = "block";

      pop.style.display = "block";

      pop.style.left = "50%";

      pop.style.top = "50%";

      pop.style.transform = "translate(-50%, -50%)";

    }



    function markWelcomeSeen() {

      localStorage.setItem(WELCOME_KEY, "1");

    }



    function shouldShowWelcome() {

      return !localStorage.getItem(WELCOME_KEY);

    }



    function closePopover() {

      if (openPop === welcomePop) markWelcomeSeen();

      backdrop.style.display = "none";

      accentPop.style.display = "none";

      soundPop.style.display = "none";

      helpPop.style.display = "none";

      settingsPop.style.display = "none";
      if (lockHistoryPop) lockHistoryPop.style.display = "none";

      welcomePop.style.display = "none";

      openPop = null;

    }



    backdrop.addEventListener("click", closePopover);

    window.addEventListener("keydown", (e) => {

      if (e.key === "Escape") closePopover();

    });



    const hRange = $("#hRange");

    const sRange = $("#sRange");

    const lRange = $("#lRange");

    const tintRange = $("#tintRange");

    const dimRange = $("#dimRange");

    const hVal = $("#hVal");

    const sVal = $("#sVal");

    const lVal = $("#lVal");

    const tintVal = $("#tintVal");

    const dimVal = $("#dimVal");

    const hexVal = $("#hexVal");

    const accentPreview = $("#accentPreview");



    function syncAccentUI() {

      const { h, s, l } = state.settings.accentHSL;

      hRange.value = h;

      sRange.value = s;

      lRange.value = l;

      hVal.textContent = `${h}¬∞`;

      sVal.textContent = `${s}%`;

      lVal.textContent = `${l}%`;

      hexVal.textContent = state.settings.accent.toLowerCase();

      accentPreview.style.background = state.settings.accent;

    }



    function syncTintUI() {

      if (!tintRange || !tintVal) return;

      const val = clamp(state.settings.taskTintSat ?? 30, 0, 100);

      tintRange.value = val;

      tintVal.textContent = `${val}%`;

    }



    function syncDimUI() {

      if (dimRange && dimVal) {

        const val = clamp(state.settings.dimOpacity ?? 25, 0, 100);

        dimRange.value = val;

        dimVal.textContent = `${val}%`;

      }

      const dimScheduleChk = $("#dimScheduleChk");

      if (dimScheduleChk) {

        dimScheduleChk.checked = !!state.settings.dimScheduleOnlyWhenChild;

      }

    }



    function syncThemeUI() {

      if (!themeDarkBtn || !themeLightBtn) return;

      const isLight = state.settings.theme === "light";

      themeDarkBtn.classList.toggle("active", !isLight);

      themeLightBtn.classList.toggle("active", isLight);

    }



    function commitAccentFromSliders() {

      const h = Number(hRange.value);

      const s = Number(sRange.value);

      const l = Number(lRange.value);

      const hex = hslToHex(h, s, l);

      state.settings.accentHSL = { h, s, l };

      state.settings.accent = hex;

      save();

      applyTheme();

      syncAccentUI();

    }



    function clampNumber(value, min, max) {

      if (Number.isNaN(value)) return null;

      return clamp(value, min, max);

    }



    function bindEditablePill(pillEl, onCommit) {

      if (!pillEl) return;

      const rangeId = pillEl.dataset.range;

      const min = Number(pillEl.dataset.min ?? 0);

      const max = Number(pillEl.dataset.max ?? 100);

      const rangeEl = rangeId ? $(`#${rangeId}`) : null;



      const finishEdit = (commit) => {

        pillEl.removeAttribute("contenteditable");

        pillEl.blur();

        const raw = pillEl.textContent ?? "";

        const numeric = Number(raw.replace(/[^\d.-]/g, ""));

        const clamped = clampNumber(numeric, min, max);

        if (commit && clamped != null && rangeEl) {

          rangeEl.value = String(clamped);

          onCommit(clamped);

        } else {

          onCommit(null, true);

        }

      };



      pillEl.addEventListener("click", () => {

        pillEl.setAttribute("contenteditable", "true");

        const text = pillEl.textContent ?? "";

        pillEl.textContent = text.replace(/[^\d.-]/g, "");

        requestAnimationFrame(() => {

          pillEl.focus();

          document.getSelection()?.selectAllChildren(pillEl);

        });

      });



      pillEl.addEventListener("keydown", (e) => {

        if (e.key === "Enter") {

          e.preventDefault();

          finishEdit(true);

        } else if (e.key === "Escape") {

          e.preventDefault();

          finishEdit(false);

        }

      });



      pillEl.addEventListener("blur", () => finishEdit(true));

    }



    [hRange, sRange, lRange].forEach((inp) => {

      inp.addEventListener("input", commitAccentFromSliders);

    });



    if (tintRange) {

      tintRange.addEventListener("input", () => {

        state.settings.taskTintSat = Number(tintRange.value);

        save();

        syncTintUI();

        renderTodos();

        renderSchedule();

      });

    }



    if (dimRange) {

      dimRange.addEventListener("input", () => {

        state.settings.dimOpacity = Number(dimRange.value);

        save();

        applyTheme();

        syncDimUI();

      });

    }



    const dimScheduleChk = $("#dimScheduleChk");

    if (dimScheduleChk) {

      dimScheduleChk.addEventListener("change", () => {

        state.settings.dimScheduleOnlyWhenChild = dimScheduleChk.checked;

        save();

        renderTodos();

        renderSchedule();

      });

    }



    bindEditablePill(hVal, (value, restoreOnly) => {

      if (restoreOnly || value == null) return syncAccentUI();

      hRange.value = String(value);

      commitAccentFromSliders();

    });



    bindEditablePill(sVal, (value, restoreOnly) => {

      if (restoreOnly || value == null) return syncAccentUI();

      sRange.value = String(value);

      commitAccentFromSliders();

    });



    bindEditablePill(lVal, (value, restoreOnly) => {

      if (restoreOnly || value == null) return syncAccentUI();

      lRange.value = String(value);

      commitAccentFromSliders();

    });



    bindEditablePill(tintVal, (value, restoreOnly) => {

      if (restoreOnly || value == null) return syncTintUI();

      tintRange.value = String(value);

      state.settings.taskTintSat = Number(tintRange.value);

      save();

      syncTintUI();

      renderTodos();

      renderSchedule();

    });



    bindEditablePill(dimVal, (value, restoreOnly) => {

      if (restoreOnly || value == null) return syncDimUI();

      dimRange.value = String(value);

      state.settings.dimOpacity = Number(dimRange.value);

      save();

      applyTheme();

      syncDimUI();

    });



    $("#themeBtn").addEventListener("click", () => {

      if (!state.settings.accentHSL) {

        const rgb = hexToRgb(state.settings.accent || "#ff5aa5");

        state.settings.accentHSL = rgb ? rgbToHsl(rgb.r, rgb.g, rgb.b) : { h: 330, s: 70, l: 60 };

      }

      syncAccentUI();

      syncTintUI();

      syncDimUI();

      syncThemeUI();

      openPopover(accentPop, $("#themeBtn"));

    });



    if (themeDarkBtn) {

      themeDarkBtn.addEventListener("click", () => {

        state.settings.theme = "dark";

        save();

        applyTheme();

        syncThemeUI();

      });

    }



    if (themeLightBtn) {

      themeLightBtn.addEventListener("click", () => {

        state.settings.theme = "light";

        save();

        applyTheme();

        syncThemeUI();

      });

    }



    const muteChk = $("#muteChk");

    const volRange = $("#volRange");

    const volVal = $("#volVal");

    const onlyIfTaskChk = $("#onlyIfTaskChk");



    function syncSoundUI() {

      muteChk.checked = !!state.settings.sound.mute;

      volRange.value = state.settings.sound.volume ?? 60;

      volVal.textContent = `${volRange.value}%`;

      onlyIfTaskChk.checked = !!state.settings.sound.onlyIfTask;

    }



    function updateUndoButton() {

      if (!undoBtn) return;

      undoBtn.disabled = deletedStack.length === 0;

      undoBtn.classList.toggle("show", deletedStack.length > 0);

    }



    function syncScheduleUI() {

      if (slot30Btn && slot60Btn) {

        const is60 = state.settings.slotMinutes === 60;

        slot30Btn.classList.toggle("active", !is60);

        slot60Btn.classList.toggle("active", is60);

      }

      if (startTimeSel && endTimeSel) {

        startTimeSel.value = String(state.settings.dayStart ?? 7);

        endTimeSel.value = String(state.settings.dayEnd ?? 22);

      }
      if (focusGoalInput) {
        focusGoalInput.value = String(state.settings.focusTargetMins ?? 120);
      }

    }



    function commitSound() {

      state.settings.sound.mute = muteChk.checked;

      state.settings.sound.volume = Number(volRange.value);

      state.settings.sound.onlyIfTask = onlyIfTaskChk.checked;

      save();

    }



    function updateScheduleSubtitle() {

      const sub = $("#schedSub");

      if (!sub) return;

      const label = SLOT_MIN === 60 ? "60-min blocks" : "30-min blocks";

      sub.textContent = `${timeString(START_H, 0)} - ${timeString(END_H, 0)} (${label})`;

    }



    function setSlotMinutes(minutes) {

      const next = minutes === 60 ? 60 : 30;

      if (state.settings.slotMinutes === next) return;

      state.settings.slotMinutes = next;

      SLOT_MIN = next;

      TIMES = allTimes(SLOT_MIN);

      save();

      syncScheduleUI();

      updateScheduleSubtitle();

      renderSchedule();

      tickCountdown(true);

      updateNowLine();

    }



    function rebuildTimes() {

      TIMES = allTimes(SLOT_MIN);

      updateScheduleSubtitle();

      renderSchedule();

      tickCountdown(true);

      updateNowLine();

    }



    function populateTimeSelects() {

      if (!startTimeSel || !endTimeSel) return;

      startTimeSel.innerHTML = "";

      endTimeSel.innerHTML = "";

      for (let h = 0; h <= 23; h += 1) {

        const label = timeString(h, 0);

        const optA = document.createElement("option");

        optA.value = String(h);

        optA.textContent = label;

        const optB = optA.cloneNode(true);

        startTimeSel.appendChild(optA);

        endTimeSel.appendChild(optB);

      }

    }



    muteChk.addEventListener("change", commitSound);

    onlyIfTaskChk.addEventListener("change", commitSound);

    volRange.addEventListener("input", () => {

      volVal.textContent = `${volRange.value}%`;

      commitSound();

    });



    $("#soundBtn").addEventListener("click", () => {

      syncSoundUI();

      openPopover(soundPop, $("#soundBtn"));

    });



    $("#settingsBtn").addEventListener("click", () => {

      syncScheduleUI();

      openPopover(settingsPop, $("#settingsBtn"));

    });

    $("#helpBtn").addEventListener("click", () => {

      openPopover(helpPop, $("#helpBtn"));

    });

    if (welcomeCloseBtn) {

      welcomeCloseBtn.addEventListener("click", () => {

        markWelcomeSeen();

        closePopover();

      });

    }

    if (welcomeHelpBtn) {

      welcomeHelpBtn.addEventListener("click", () => {

        markWelcomeSeen();

        closePopover();

        openPopover(helpPop, $("#helpBtn"));

      });

    }

    if (undoBtn) {

      updateUndoButton();

      undoBtn.addEventListener("click", () => {

        if (deletedStack.length === 0) return;

        const lastDeleted = deletedStack.pop();

        if (lastDeleted?.type === "todo") {

          const insertIdx = Math.min(lastDeleted.index, state.todos.length);

          state.todos.splice(insertIdx, 0, lastDeleted.item);

          save();

          renderTodos();

        }

        updateUndoButton();

      });

    }



    if (slot30Btn) slot30Btn.addEventListener("click", () => setSlotMinutes(30));

    if (slot60Btn) slot60Btn.addEventListener("click", () => setSlotMinutes(60));



    populateTimeSelects();

    if (startTimeSel) {

      startTimeSel.addEventListener("change", () => {

        const nextStart = Number(startTimeSel.value);

        if (Number.isNaN(nextStart)) return;

        const endVal = state.settings.dayEnd ?? 22;

        state.settings.dayStart = Math.min(nextStart, endVal - 1);

        START_H = state.settings.dayStart;

        save();

        syncScheduleUI();

        rebuildTimes();

      });

    }



    if (endTimeSel) {

      endTimeSel.addEventListener("change", () => {

        const nextEnd = Number(endTimeSel.value);

        if (Number.isNaN(nextEnd)) return;

        const startVal = state.settings.dayStart ?? 7;

        state.settings.dayEnd = Math.max(nextEnd, startVal + 1);

        END_H = state.settings.dayEnd;

        save();

        syncScheduleUI();

        rebuildTimes();

      });

    }

    if (focusGoalInput) {
      focusGoalInput.addEventListener("change", () => {
        const next = Number(focusGoalInput.value);
        if (Number.isNaN(next) || next <= 0) return;
        state.settings.focusTargetMins = next;
        save();
        syncScheduleUI();
        renderLockHistory();
      });
    }




    const previewWarnBtn = $("#previewWarn");

    const previewEndBtn = $("#previewEnd");

    if (previewWarnBtn) {

      previewWarnBtn.addEventListener("click", () => {

        playWarningSound(true);

      });

    }

    if (previewEndBtn) {

      previewEndBtn.addEventListener("click", () => {

        playEndSound(true);

      });

    }



    const monthLabel = $("#monthLabel");

    const calGrid = $("#calGrid");

    const dateLabel = $("#dateLabel");



    const today = new Date();

    let viewMonth = new Date(today.getFullYear(), today.getMonth(), 1);

    let selected = new Date(today.getFullYear(), today.getMonth(), today.getDate());

    function setSelectedDate(nextDate) {
      if (!nextDate) return;
      selected = new Date(nextDate.getFullYear(), nextDate.getMonth(), nextDate.getDate());
      viewMonth = new Date(selected.getFullYear(), selected.getMonth(), 1);
      renderCalendar();
      renderSchedule();
      tickCountdown(true);
      updateNowLine();
      updateLockUI();
      renderLockHistory();
      if (lockHistoryDate) lockHistoryDate.value = toDateInputValue(selected);
    }



    $("#prevMonth").addEventListener("click", () => {

      viewMonth = new Date(viewMonth.getFullYear(), viewMonth.getMonth() - 1, 1);

      renderCalendar();

    });



    $("#nextMonth").addEventListener("click", () => {

      viewMonth = new Date(viewMonth.getFullYear(), viewMonth.getMonth() + 1, 1);

      renderCalendar();

    });



    function renderCalendar() {

      calGrid.innerHTML = "";

      monthLabel.textContent = viewMonth.toLocaleString(undefined, { month: "long", year: "numeric" });



      const first = new Date(viewMonth.getFullYear(), viewMonth.getMonth(), 1);

      const last = new Date(viewMonth.getFullYear(), viewMonth.getMonth() + 1, 0);



      const blanks = first.getDay();

      for (let i = 0; i < blanks; i += 1) {

        const b = document.createElement("div");

        b.className = "day blank";

        calGrid.appendChild(b);

      }



      for (let day = 1; day <= last.getDate(); day += 1) {

        const d = new Date(viewMonth.getFullYear(), viewMonth.getMonth(), day);

        const cell = document.createElement("div");

        cell.className = "day";

        cell.textContent = day;



        if (isPastDay(d, today)) cell.classList.add("past");

        if (isSameDay(d, today)) cell.classList.add("today");

        if (isSameDay(d, selected)) cell.classList.add("active");



        cell.addEventListener("click", () => {
          setSelectedDate(d);
        });



        calGrid.appendChild(cell);

      }

    }



    let hoveredRow = null;



    function clearDragStyles() {

      $$(".dropzone.active").forEach((el) => el.classList.remove("active"));

      $$(".droptarget").forEach((el) => el.classList.remove("droptarget"));

      $$(".row.insert-gap").forEach((el) => el.classList.remove("insert-gap"));

      hoveredRow = null;

    }





    function createHandle(config) {

      const handle = document.createElement("div");

      handle.className = "handle";

      handle.draggable = false;

      handle.addEventListener("pointerdown", (e) => startPointerDrag(e, config));

      return handle;

    }



    const pointerDrag = {

      active: false,

      type: null,

      fromIndex: null,

      fromTime: null,

      fromDateKey: null,

      sourceEl: null,

      ghostEl: null,

      placeholderEl: null,

      offsetX: 0,

      offsetY: 0,

      targetType: null,

      targetIndex: null,

      pointerId: null,

      handleEl: null,

      pending: false,

      startX: 0,

      startY: 0,

      originalTime: null,

      groupIds: null,

      groupCount: 1,

      hiddenEls: null,

      hoverTodoId: null

    };



    function resetScheduleTimes() {

      rowsEl.querySelectorAll(".row").forEach((row) => {

        const timeEl = row.querySelector(".time");

        if (timeEl && row.dataset.time) timeEl.textContent = row.dataset.time;

      });

    }



    function applySchedulePreviewTimes(rows, targetIdx) {

      rows.forEach((row, i) => {

        const timeEl = row.querySelector(".time");

        if (!timeEl) return;

        const timeIndex = i >= targetIdx ? i + 1 : i;

        timeEl.textContent = TIMES[timeIndex] ?? row.dataset.time;

      });

    }



    function startPointerDrag(e, config) {

      if (e.button !== 0) return;

      e.preventDefault();

      pointerDrag.pending = true;

      pointerDrag.pointerId = e.pointerId;

      pointerDrag.handleEl = e.currentTarget;

      pointerDrag.startX = e.clientX;

      pointerDrag.startY = e.clientY;

      pointerDrag.type = config.type;

      pointerDrag.fromIndex = config.fromIndex ?? null;

      pointerDrag.fromTime = config.fromTime ?? null;

      pointerDrag.fromDateKey = config.fromDateKey ?? null;

      pointerDrag.originalTime = config.fromTime ?? null;

      pointerDrag.sourceEl = config.draggingEl ?? null;

      if (pointerDrag.type === "todo" && pointerDrag.fromIndex != null) {

        const rootId = state.todos[pointerDrag.fromIndex]?.id;

        pointerDrag.groupIds = rootId ? getTodoGroupIds(rootId) : null;

        pointerDrag.groupCount = pointerDrag.groupIds ? pointerDrag.groupIds.size : 1;

      } else {

        pointerDrag.groupIds = null;

        pointerDrag.groupCount = 1;

      }

      pointerDrag.targetType = null;

      pointerDrag.targetIndex = null;

      pointerDrag.hoverTodoId = null;



      if (!pointerDrag.sourceEl) return;



      if (pointerDrag.handleEl?.setPointerCapture) {

        pointerDrag.handleEl.setPointerCapture(pointerDrag.pointerId);

      }



      document.addEventListener("pointermove", onPointerMove);

      document.addEventListener("pointerup", onPointerUp, { once: true });

      document.addEventListener("pointercancel", onPointerCancel, { once: true });

    }



    function beginPointerDrag(e) {

      pointerDrag.active = true;

      pointerDrag.pending = false;

      const rect = pointerDrag.sourceEl.getBoundingClientRect();

      pointerDrag.offsetX = e.clientX - rect.left;

      pointerDrag.offsetY = e.clientY - rect.top;

      const gapHeight = pointerDrag.type === "todo" ? Math.round(rect.height * (pointerDrag.groupCount || 1)) : Math.round(rect.height);

      document.documentElement.style.setProperty("--dragGap", `${gapHeight}px`);



      let ghost;

      if (pointerDrag.type === "todo") {

        ghost = document.createElement("div");

        ghost.className = "drag-ghost todo-ghost";

        const todoText = pointerDrag.sourceEl.querySelector(".todo-text")?.textContent ?? "";

        const time = document.createElement("div");

        time.className = "todo-ghost-time";

        time.textContent = "";

        const text = document.createElement("div");

        text.className = "todo-ghost-text";

        text.textContent = todoText || " ";

        ghost.append(time, text);

      } else {

        ghost = pointerDrag.sourceEl.cloneNode(true);

        ghost.classList.add("drag-ghost");

      }

      ghost.style.width = `${rect.width}px`;

      ghost.style.height = `${rect.height}px`;

      ghost.style.transform = `translate3d(${rect.left}px, ${rect.top}px, 0)`;

      ghost.style.opacity = "1";

      document.body.appendChild(ghost);

      pointerDrag.ghostEl = ghost;



      pointerDrag.sourceEl.classList.add("dragging");

      document.body.classList.add("dragging");

      if (pointerDrag.type === "todo") {

        pointerDrag.sourceEl.classList.add("drag-source");

      } else {

        pointerDrag.sourceEl.style.display = "none";

      }



      if (pointerDrag.type === "todo") {

        if (pointerDrag.groupIds && pointerDrag.groupIds.size > 1) {

          const hidden = [];

          todoList.querySelectorAll(".item").forEach((el) => {

            if (el === pointerDrag.sourceEl) return;

            const id = el.dataset.todoId;

            if (id && pointerDrag.groupIds.has(id)) {

              el.classList.add("drag-hidden");

              hidden.push(el);

            }

          });

          pointerDrag.hiddenEls = hidden;

        }

        const placeholder = document.createElement("div");

        placeholder.className = "drag-placeholder";

        pointerDrag.placeholderEl = placeholder;

        todoList.insertBefore(placeholder, pointerDrag.sourceEl.nextSibling);

      }

    }



    function setGhostTimeLabel(timeText) {

      if (!pointerDrag.ghostEl) return;

      const timeEl = pointerDrag.ghostEl.querySelector(".time");

      if (timeEl) {

        timeEl.textContent = timeText || "";

        return;

      }

      const todoTime = pointerDrag.ghostEl.querySelector(".todo-ghost-time");

      if (todoTime) {

        todoTime.textContent = timeText || "";

        todoTime.classList.toggle("is-empty", !timeText);

        return;

      }

      const badge = pointerDrag.ghostEl.querySelector(".ghost-time");

      if (!timeText) {

        if (badge) badge.remove();

        return;

      }

      const nextBadge = badge || document.createElement("div");

      nextBadge.className = "ghost-time";

      nextBadge.textContent = timeText;

      if (!badge) pointerDrag.ghostEl.appendChild(nextBadge);

    }



    function updateGhostPosition(x, y) {

      if (!pointerDrag.ghostEl) return;

      const left = x - pointerDrag.offsetX;

      const top = y - pointerDrag.offsetY;

      pointerDrag.ghostEl.style.transform = `translate3d(${left}px, ${top}px, 0)`;

    }



    function onPointerMove(e) {

      if (pointerDrag.pending) {

        const dx = e.clientX - pointerDrag.startX;

        const dy = e.clientY - pointerDrag.startY;

        if (Math.hypot(dx, dy) < 4) return;

        beginPointerDrag(e);

      }

      if (!pointerDrag.active) return;

      updateGhostPosition(e.clientX, e.clientY);



      const el = document.elementFromPoint(e.clientX, e.clientY);

      const scheduleRect = rowsEl.getBoundingClientRect();

      const overSchedule =

        e.clientX >= scheduleRect.left &&

        e.clientX <= scheduleRect.right &&

        e.clientY >= scheduleRect.top &&

        e.clientY <= scheduleRect.bottom;



      if (overSchedule) {

        const rows = Array.from(rowsEl.querySelectorAll(".row")).filter((row) => row !== pointerDrag.sourceEl);

        let targetIdx = rows.length;

        for (let i = 0; i < rows.length; i += 1) {

          const r = rows[i].getBoundingClientRect();

          if (e.clientY < r.top + r.height / 2) {

            targetIdx = i;

            break;

          }

        }

        pointerDrag.targetType = "schedule";

        pointerDrag.targetIndex = targetIdx;

        if (!pointerDrag.placeholderEl) {

          const placeholder = document.createElement("div");

          placeholder.className = "drag-placeholder";

          pointerDrag.placeholderEl = placeholder;

        }

        const targetRow = rows[targetIdx] ?? null;

        rowsEl.insertBefore(pointerDrag.placeholderEl, targetRow);

        applySchedulePreviewTimes(rows, targetIdx);

        if (pointerDrag.type === "slot" || pointerDrag.type === "todo") {

          const previewTime = TIMES[Math.min(targetIdx, TIMES.length - 1)] ?? pointerDrag.originalTime;

          setGhostTimeLabel(previewTime);

        }

        if (hoveredRow) hoveredRow.classList.remove("insert-gap");

        hoveredRow = null;

        return;

      }



      if (el && todoList.contains(el)) {

        pointerDrag.targetType = "todo";

        pointerDrag.hoverTodoId = getHoverTodoIdFromPoint(e.clientX, e.clientY);

        todoList.querySelectorAll(".item.parent-highlight").forEach((i) => i.classList.remove("parent-highlight"));

        if (pointerDrag.hoverTodoId) {

          const hoverTodo = state.todos.find((t) => t.id === pointerDrag.hoverTodoId);

          const parentId = hoverTodo?.parentId || hoverTodo?.id;

          if (parentId) {

            const parentItem = todoList.querySelector(`.item[data-todo-id="${parentId}"]`);

            if (parentItem) parentItem.classList.add("parent-highlight");

          }

        }

        if (!pointerDrag.placeholderEl) {

          const placeholder = document.createElement("div");

          placeholder.className = "drag-placeholder";

          pointerDrag.placeholderEl = placeholder;

        }

        const items = Array.from(todoList.querySelectorAll(".item")).filter((item) => {

          if (item === pointerDrag.sourceEl) return false;

          if (pointerDrag.groupIds && item.dataset.todoId && pointerDrag.groupIds.has(item.dataset.todoId)) return false;

          return true;

        });

        let targetIndex = items.length;

        for (let i = 0; i < items.length; i += 1) {

          const r = items[i].getBoundingClientRect();

          if (e.clientY < r.top + r.height / 2) {

            targetIndex = i;

            break;

          }

        }

        pointerDrag.targetIndex = targetIndex;

        if (pointerDrag.placeholderEl) {

          const beforeEl = items[targetIndex] ?? null;

          todoList.insertBefore(pointerDrag.placeholderEl, beforeEl);

        }

        if (pointerDrag.type === "slot" && pointerDrag.originalTime) {

          setGhostTimeLabel(pointerDrag.originalTime);

        } else if (pointerDrag.type === "todo") {

          setGhostTimeLabel("");

        }

        resetScheduleTimes();

        if (hoveredRow) hoveredRow.classList.remove("insert-gap");

        hoveredRow = null;

        return;

      }



      if (pointerDrag.type === "slot" && pointerDrag.originalTime) {

        setGhostTimeLabel(pointerDrag.originalTime);

      } else if (pointerDrag.type === "todo") {

        setGhostTimeLabel("");

      }

      pointerDrag.hoverTodoId = null;

      todoList.querySelectorAll(".item.parent-highlight").forEach((i) => i.classList.remove("parent-highlight"));

      resetScheduleTimes();

      if (hoveredRow) hoveredRow.classList.remove("insert-gap");

      hoveredRow = null;

    }



    function finalizePointerDrag() {

      if (pointerDrag.handleEl?.releasePointerCapture && pointerDrag.pointerId != null) {

        pointerDrag.handleEl.releasePointerCapture(pointerDrag.pointerId);

      }

      if (pointerDrag.sourceEl) {

        pointerDrag.sourceEl.classList.remove("dragging");

        pointerDrag.sourceEl.classList.remove("drag-source");

        pointerDrag.sourceEl.style.display = "";

        pointerDrag.sourceEl.style.visibility = "";

      }

      if (pointerDrag.hiddenEls?.length) {

        pointerDrag.hiddenEls.forEach((el) => el.classList.remove("drag-hidden"));

      }

      if (pointerDrag.ghostEl) pointerDrag.ghostEl.remove();

      if (pointerDrag.placeholderEl) pointerDrag.placeholderEl.remove();

      document.body.classList.remove("dragging");

      document.documentElement.style.removeProperty("--dragGap");

      clearDragStyles();

      resetScheduleTimes();

      pointerDrag.active = false;

      pointerDrag.type = null;

      pointerDrag.fromIndex = null;

      pointerDrag.fromTime = null;

      pointerDrag.fromDateKey = null;

      pointerDrag.sourceEl = null;

      pointerDrag.ghostEl = null;

      pointerDrag.placeholderEl = null;

      pointerDrag.targetType = null;

      pointerDrag.targetIndex = null;

      pointerDrag.pointerId = null;

      pointerDrag.handleEl = null;

      pointerDrag.originalTime = null;

      pointerDrag.groupIds = null;

      pointerDrag.groupCount = 1;

      pointerDrag.hiddenEls = null;

      pointerDrag.hoverTodoId = null;

      todoList.querySelectorAll(".item.parent-highlight").forEach((i) => i.classList.remove("parent-highlight"));

    }



    function onPointerCancel() {

      document.removeEventListener("pointermove", onPointerMove);

      finalizePointerDrag();

    }



    function onPointerUp() {

      document.removeEventListener("pointermove", onPointerMove);

      if (pointerDrag.pending) {

        finalizePointerDrag();

        return;

      }

      if (!pointerDrag.active) return;



      const targetType = pointerDrag.targetType;

      const targetIndex = pointerDrag.targetIndex;

      const dk = dateKey(selected);



      if (targetType === "todo" && pointerDrag.type === "todo" && targetIndex != null) {

        const from = pointerDrag.fromIndex;

        if (from != null) {

          const root = state.todos[from];

          const groupIds = pointerDrag.groupIds ?? (root ? new Set([root.id]) : new Set());

          const remaining = state.todos.filter((t) => !groupIds.has(t.id));

          const group = state.todos.filter((t) => groupIds.has(t.id));

          const insertBaseIdx = Math.max(0, Math.min(targetIndex, remaining.length));

          const hoverTodo = pointerDrag.hoverTodoId ? remaining.find((t) => t.id === pointerDrag.hoverTodoId) : null;

          const targetTodo = hoverTodo || remaining[insertBaseIdx] || null;

          const isRootParent = isParentTodo(root);

          let newParentId = root?.parentId ?? null;

          let newParentName = root?.parentName ?? null;



          if (targetTodo && root) {

            if (targetTodo.parentId) {

              newParentId = targetTodo.parentId;

              const parent = findTodoById(newParentId);

              newParentName = parent?.text || targetTodo.parentName || "Unknown";

            } else {

              const parentIdx = remaining.findIndex((t) => t.id === targetTodo.id);

              if (insertBaseIdx <= parentIdx && !hoverTodo) {

                newParentId = null;

                newParentName = null;

              } else {

                newParentId = targetTodo.id;

                newParentName = targetTodo.text || "Parent task";

              }

            }

          }



          if (group[0]) {

            group[0].parentId = newParentId || null;

            group[0].parentName = newParentName || null;

          }



          let insertIdx = insertBaseIdx;

          if (newParentId) {

            insertIdx = findInsertIndexForParent(remaining, newParentId, hoverTodo?.id || null);

          }

          state.todos = [...remaining.slice(0, insertIdx), ...group, ...remaining.slice(insertIdx)];

        }

      } else if (targetType === "schedule" && pointerDrag.type === "todo" && targetIndex != null) {

        const item = state.todos[pointerDrag.fromIndex];

        if (item) {

          if (isParentTodo(item)) {

            showError("Parent tasks can't be moved into the schedule.");

            finalizePointerDrag();

            return;

          }

          const targetTime = TIMES[Math.min(targetIndex, TIMES.length - 1)];

          const inserted = insertIntoSchedule(dk, targetTime, item);

          if (inserted) state.todos.splice(pointerDrag.fromIndex, 1);

        }

      } else if (targetType === "schedule" && pointerDrag.type === "slot" && targetIndex != null) {

        const fromIdx = TIMES.indexOf(pointerDrag.fromTime);

        if (fromIdx !== -1) {

          const arr = getScheduleArray(dk);

          const toIdx = Math.min(targetIndex, arr.length);

          if (fromIdx !== toIdx) {

            const [moved] = arr.splice(fromIdx, 1);

            const insertIdx = Math.min(toIdx, arr.length);

            arr.splice(insertIdx, 0, moved);

            setScheduleFromArray(dk, arr);

          }

        }

      } else if (targetType === "todo" && pointerDrag.type === "slot") {

        const item = getSlotItem(pointerDrag.fromDateKey, pointerDrag.fromTime);

        if (item) {

          deleteSlot(pointerDrag.fromDateKey, pointerDrag.fromTime);

          const insertIdx = Math.min(pointerDrag.targetIndex ?? state.todos.length, state.todos.length);

          state.todos.splice(insertIdx, 0, item);

        }

      }



      save();

      renderTodos();

      renderSchedule();

      const released = document.querySelectorAll(".row, .item");

      released.forEach((el) => el.classList.add("release"));

      setTimeout(() => released.forEach((el) => el.classList.remove("release")), 340);

      finalizePointerDrag();

    }



    const todoInput = $("#todoInput");

    const todoList = $("#todoList");

    const rowsEl = $("#rows");



    todoInput.addEventListener("keydown", (e) => {

      if (e.key === "Enter") {

        const v = todoInput.value.trim();

        if (!v) return;

        state.todos.push({ id: makeId(), text: v, done: false });

        todoInput.value = "";

        save();

        renderTodos();

      }

    });



    function renderTodos() {

      todoList.innerHTML = "";

      const todoCount = $("#todoCount");

      if (todoCount) {

        const total = state.todos.length;

        const done = state.todos.filter((t) => t.done).length;

        todoCount.textContent = total ? `${done}/${total}` : "0";

      }



      if (state.todos.length === 0) {

        const empty = document.createElement("div");

        empty.style.color = "var(--muted)";

        empty.style.fontSize = "12px";

        empty.style.padding = "6px 8px";

        empty.textContent = "No todos yet.";

        todoList.appendChild(empty);

        updateUndoButton();

        return;

      }



      state.todos.forEach((todo, idx) => {

        const item = document.createElement("div");

        item.className = "item";

        item.dataset.todoId = todo.id;

        if (todo.parentId) item.classList.add("child");

        if (todo.parentId) item.dataset.parentId = todo.parentId;

        const isParent = isParentTodo(todo);

        if (todo.done) item.classList.add("done");

        const parentColors = todo.parentId ? getParentColors(todo.parentId) : (isParent ? getParentColors(todo.id) : null);

        if (parentColors) {

          item.classList.add("parent-color");

          item.style.setProperty("--parentTint", parentColors.tint);

          item.style.setProperty("--parentBorder", parentColors.border);

        }



        const handle = createHandle({

          type: "todo",

          fromList: "todo",

          fromIndex: idx,

          itemId: todo.id,

          payload: todo.text,

          draggingEl: item

        });



        const label = document.createElement("div");

        label.className = "todo-text";

        label.textContent = todo.text;

        label.contentEditable = "true";

        label.spellcheck = false;

        label.addEventListener("dragover", (e) => e.preventDefault());

        label.addEventListener("drop", (e) => {

          e.preventDefault();

          e.stopPropagation();

        });

        label.addEventListener("input", () => {

          todo.text = label.textContent;

          save();

        });

        label.addEventListener("keydown", (e) => {

          if (e.key === "Enter") {

            e.preventDefault();

            label.blur();

          }

        });



        const splitBtn = document.createElement("button");

        splitBtn.type = "button";

        splitBtn.className = "todo-split";

        if (todo.parentId) splitBtn.classList.add("is-hidden");

        splitBtn.setAttribute("aria-label", "Add subtask");

        splitBtn.addEventListener("click", () => {

          const child = {

            id: makeId(),

            text: "Subtask...",

            done: false,

            parentId: todo.id,

            parentName: todo.text

          };

          let insertIdx = idx + 1;

          for (let i = idx + 1; i < state.todos.length; i += 1) {

            if (state.todos[i].parentId === todo.id) insertIdx = i + 1;

          }

          state.todos.splice(insertIdx, 0, child);

          pendingFocusId = child.id;

          save();

          renderTodos();

        });



        const delBtn = document.createElement("button");

        delBtn.type = "button";

        delBtn.className = "todo-delete";

        delBtn.setAttribute("aria-label", "Delete todo");

        delBtn.textContent = "";

        delBtn.addEventListener("click", () => {

          const [removed] = state.todos.splice(idx, 1);

          if (removed) {

            deletedStack.push({ type: "todo", item: removed, index: idx });

            updateUndoButton();

          }

          save();

          renderTodos();

        });



        const tickBtn = document.createElement("button");

        tickBtn.type = "button";

        tickBtn.className = "tick-btn";

        tickBtn.setAttribute("aria-label", "Mark complete");

        tickBtn.setAttribute("aria-pressed", String(!!todo.done));

        tickBtn.addEventListener("click", () => {

          todo.done = !todo.done;

          save();

          renderTodos();

        });



        item.addEventListener("mouseenter", () => applyTodoDim(todo));

        item.addEventListener("mouseleave", (e) => {

          if (item.contains(e.relatedTarget)) return;

          scheduleDimClear();

        });



        item.addEventListener("dragover", (e) => e.preventDefault());

        item.addEventListener("drop", (e) => {

          if (e.target.classList.contains("dropzone")) return;

          e.preventDefault();

          e.stopPropagation();

        });



        item.append(handle, label, splitBtn, delBtn, tickBtn);

        todoList.appendChild(item);



        if (pendingFocusId && pendingFocusId === todo.id) {

          pendingFocusId = null;

          label.focus();

          document.getSelection()?.selectAllChildren(label);

        }

      });

      updateUndoButton();

    }



    

    function getScheduleArray(dk) {

      ensureSchedule(dk);

      return TIMES.map((t) => state.schedules[dk]?.[t] ?? null);

    }



    function setScheduleFromArray(dk, arr) {

      ensureSchedule(dk);

      TIMES.forEach((t, i) => {

        const item = arr[i];

        if (item && item.text && item.text.trim()) state.schedules[dk][t] = item;

        else delete state.schedules[dk][t];

      });

    }



function deleteSlot(dk, t) {

      if (state.schedules?.[dk]) delete state.schedules[dk][t];

    }



    function insertIntoSchedule(dk, targetTime, item) {

      ensureSchedule(dk);

      const sched = state.schedules[dk];

      if (!item || !item.text || !item.text.trim()) return false;



      if (!sched[targetTime]) {

        sched[targetTime] = item;

        return true;

      }



      const startIdx = TIMES.indexOf(targetTime);

      if (startIdx === -1) return false;



      let emptyIdx = -1;

      for (let i = startIdx; i < TIMES.length; i += 1) {

        if (!sched[TIMES[i]]) {

          emptyIdx = i;

          break;

        }

      }



      if (emptyIdx === -1) return false;



      for (let i = emptyIdx; i > startIdx; i -= 1) {

        const fromT = TIMES[i - 1];

        const toT = TIMES[i];

        sched[toT] = sched[fromT];

      }

      sched[targetTime] = item;

      return true;

    }



    const nowLine = $("#nowLine");

    const nowPill = $("#nowPill");



    function renderSchedule() {

      const dk = dateKey(selected);

      ensureSchedule(dk);

      updateScheduleSubtitle();

      dateLabel.textContent = selected.toLocaleDateString(undefined, {

        weekday: "short",

        month: "short",

        day: "numeric",

        year: "numeric"

      });



      rowsEl.innerHTML = "";



      TIMES.forEach((tkey, index) => {

        const row = document.createElement("div");

        row.className = "row";

        row.dataset.time = tkey;



        const slotItem = getSlotItem(dk, tkey);

        const slotText = slotItem?.text ?? "";

        const parentColors = slotItem?.parentId ? getParentColors(slotItem.parentId) : null;

        if (parentColors) {

          row.classList.add("parent-color");

          row.style.setProperty("--parentTint", parentColors.tint);

          row.style.setProperty("--parentBorder", parentColors.border);

        }



        if (isPastTimeSlot(selected, tkey)) row.classList.add("past");

        if (slotItem?.done) row.classList.add("done");

        if (isBlockLocked(dk, tkey)) row.classList.add("locked");



        const time = document.createElement("div");

        time.className = "time";

        time.textContent = tkey;



        const handle = createHandle({

          type: "slot",

          fromList: "schedule",

          fromDateKey: dk,

          fromTime: tkey,

          itemId: slotItem?.id ?? null,

          payload: slotText,

          draggingEl: row,

          canDrag: true

        });



        const input = document.createElement("input");

        input.className = "editor";

        input.placeholder = "Type task...";

        input.value = slotText;



        const infoIcon = document.createElement("span");

        infoIcon.className = "info-icon";

        infoIcon.setAttribute("aria-label", "Parent task info");

        const parentName = slotItem?.parentId ? (findTodoById(slotItem.parentId)?.text || slotItem.parentName || "Unknown") : "";

        if (parentName) infoIcon.removeAttribute("title");

        infoIcon.textContent = "‚ìò";

        const clearDim = () => {

          scheduleDimClear();

        };

        const applyDim = () => {

          cancelDimClear();

          rowsEl.querySelectorAll(".row").forEach((r) => r.classList.add("dim"));

          todoList.querySelectorAll(".item").forEach((i) => i.classList.add("dim"));

          row.classList.remove("dim");

          const parentRow = rowsEl.querySelector(`.row[data-parent-id="${slotItem.parentId}"]`);

          if (parentRow) parentRow.classList.remove("dim");

          if (slotItem.parentId) {

            const parentItem = todoList.querySelector(`.item[data-todo-id="${slotItem.parentId}"]`);

            if (parentItem) parentItem.classList.remove("dim");

            todoList.querySelectorAll(`.item[data-parent-id="${slotItem.parentId}"]`).forEach((i) => i.classList.remove("dim"));

          }

        };

        if (parentName) {

          infoIcon.dataset.parentName = parentName;

          infoIcon.addEventListener("mouseenter", applyDim);

          infoIcon.addEventListener("mouseenter", () => {

            if (infoTip) {

              infoTip.textContent = `Child of ${parentName}`;

              const rect = infoIcon.getBoundingClientRect();

              const left = Math.min(rect.left, window.innerWidth - infoTip.offsetWidth - 8);

              const top = Math.min(window.innerHeight - 8, rect.bottom + 6);

              infoTip.style.left = `${left}px`;

              infoTip.style.top = `${top}px`;

              infoTip.classList.add("show");

            }

          });

          infoIcon.addEventListener("mouseleave", () => {

            if (row.matches(":hover")) return;

            if (infoTip) infoTip.classList.remove("show");

            clearDim();

          });

          row.addEventListener("mouseenter", applyDim);

          row.addEventListener("mouseleave", (e) => {

            if (row.contains(e.relatedTarget)) return;

            if (infoTip) infoTip.classList.remove("show");

            clearDim();

          });

        }



        const tickBtn = document.createElement("button");

        tickBtn.type = "button";

        tickBtn.className = "tick-btn";

        tickBtn.setAttribute("aria-label", "Mark complete");

        tickBtn.setAttribute("aria-pressed", String(!!slotItem?.done));

        tickBtn.addEventListener("click", () => {

          setSlotDone(dk, tkey, !slotItem?.done);

          save();

          renderSchedule();

        });



        const delBtn = document.createElement("button");

        delBtn.type = "button";

        delBtn.className = "row-delete";

        delBtn.setAttribute("aria-label", "Delete task");

        delBtn.addEventListener("click", () => {

          deleteSlot(dk, tkey);

          save();

          clearAllDim();

          renderSchedule();

        });



        row.addEventListener("mousedown", (e) => {

          if (e.target === handle || e.target === tickBtn) return;

          input.focus();

        });



        input.addEventListener("input", () => {

          setSlotText(dk, tkey, input.value);

          if (!input.value.trim()) setSlotDone(dk, tkey, false);

          save();

          tickCountdown(true);

        });



        const actions = document.createElement("div");

        actions.className = "row-actions";

        if (slotItem?.parentId) actions.appendChild(infoIcon);

        actions.appendChild(delBtn);

        actions.appendChild(tickBtn);

        if (parentName) {

          actions.addEventListener("mouseenter", applyDim);

          actions.addEventListener("mouseleave", (e) => {

            if (row.contains(e.relatedTarget)) return;

            if (infoTip) infoTip.classList.remove("show");

            clearDim();

          });

        }

        row.append(time, handle, input, actions);

        if (slotItem?.parentId) row.dataset.parentId = slotItem.parentId;

        rowsEl.appendChild(row);



      });



      updateNowLine();

    }



    function updateNowLine() {

      if (!isSameDay(selected, new Date())) {

        nowLine.style.display = "none";

        nowPill.style.display = "none";

        return;

      }



      const now = new Date();

      const startMinutes = START_H * 60;

      const endMinutes = END_H * 60;

      const nowMinutes = now.getHours() * 60 + now.getMinutes();



      if (nowMinutes < startMinutes || nowMinutes >= endMinutes) {

        nowLine.style.display = "none";

        nowPill.style.display = "none";

        return;

      }



      const rowEl = rowsEl.querySelector(".row");

      const rowH = rowEl ? rowEl.getBoundingClientRect().height : 36;

      const pxPerMin = rowH / SLOT_MIN;

      const minsInto = nowMinutes - startMinutes;

      const topPx = minsInto * pxPerMin;



      nowLine.style.display = "block";

      nowPill.style.display = "block";

      nowLine.style.top = `${topPx}px`;

      nowPill.style.top = `${topPx}px`;

      nowPill.textContent = now.toTimeString().slice(0, 5);

    }



    const soundState = {

      audioCtx: null,

      lastWarnKey: null,

      lastEndKey: null

    };



    const WARNING_SRC = "warning-sound.mp3";

    const END_SRC = "alert-sound.mp3";



    function playTone(freq, durationMs, force = false) {

      if (!force && state.settings.sound.mute) return;

      const volume = clamp((state.settings.sound.volume ?? 60) / 100, 0, 1);

      if (volume === 0) return;

      if (!soundState.audioCtx) {

        soundState.audioCtx = new (window.AudioContext || window.webkitAudioContext)();

      }

      const ctx = soundState.audioCtx;

      const osc = ctx.createOscillator();

      const gain = ctx.createGain();

      osc.type = "sine";

      osc.frequency.value = freq;

      gain.gain.value = volume * 0.2;

      osc.connect(gain);

      gain.connect(ctx.destination);

      osc.start();

      osc.stop(ctx.currentTime + durationMs / 1000);

    }



    function playChime(src, force = false) {

      if (!force && state.settings.sound.mute) return;

      const volume = clamp((state.settings.sound.volume ?? 60) / 100, 0, 1);

      if (volume === 0) return;

      const audio = new Audio(src);

      audio.volume = volume;

      audio.play().catch(() => {});

    }



    function playWarningSound(force = false) {

      playChime(WARNING_SRC, force);

    }



    function playEndSound(force = false) {

      playChime(END_SRC, force);

    }



    function shouldPlayForCurrentBlock(blockInfo) {

      if (!blockInfo) return false;

      if (!state.settings.sound.onlyIfTask) return true;

      const dk = dateKey(selected);

      const text = getSlotText(dk, blockInfo.timeKey);

      return !!text;

    }



    function checkSoundAlerts() {

      const blockInfo = getCurrentBlockInfo();

      if (!blockInfo) return;

      if (!isSameDay(selected, new Date())) return;

      if (!shouldPlayForCurrentBlock(blockInfo)) return;



      const dk = dateKey(selected);

      const blockKey = `${dk}-${blockInfo.timeKey}`;



      if (blockInfo.remainingMins === 5 && soundState.lastWarnKey !== blockKey) {

        soundState.lastWarnKey = blockKey;

        playWarningSound();

      }



      if (blockInfo.remainingMins === 0 && soundState.lastEndKey !== blockKey) {

        soundState.lastEndKey = blockKey;

        playEndSound();

      }

    }



    const countdownEl = $("#countdown");

    const timerNowEl = $("#timerNow");

    const timerNextEl = $("#timerNext");

    const lockBtn = $("#lockBtn");
    const timerCard = document.querySelector(".timer-card");
    const lockinPanel = document.querySelector(".lockin-panel");
    const panelRangeEl = $("#panelRange");

    const panelTaskEl = $("#panelTask");

    const panelCtaTextEl = $("#panelCtaText");

    const panelElapsedEl = $("#panelElapsed");



    function blockLabel(info) {

      const endH = Math.floor(info.slotEndMins / 60);

      const endM = info.slotEndMins % 60;

      return `${info.timeKey}-${timeString(endH, endM)}`;

    }



    function formatDuration(totalSeconds) {

      const secs = Math.max(0, Math.floor(totalSeconds));

      const mins = Math.floor(secs / 60);

      const rem = secs % 60;

      return `${String(mins).padStart(2, "0")}:${String(rem).padStart(2, "0")}`;

    }

    function formatLockStart(lock) {
      if (!lock || typeof lock.startedAt !== "number") return "--:--";
      const started = new Date(lock.startedAt);
      const time = started.toTimeString().slice(0, 5);
      const now = new Date();
      if (!isSameDay(started, now)) {
        const dateLabel = started.toLocaleDateString(undefined, { month: "short", day: "numeric" });
        return `Locked since ${dateLabel} ${time}`;
      }
      return `Locked since ${time}`;
    }

    function toDateInputValue(d) {
      const pad = (n) => String(n).padStart(2, "0");
      return `${d.getFullYear()}-${pad(d.getMonth() + 1)}-${pad(d.getDate())}`;
    }

    function fromDateInputValue(value) {
      if (!value) return null;
      const d = new Date(value);
      const ms = d.getTime();
      if (Number.isNaN(ms)) return null;
      return new Date(d.getFullYear(), d.getMonth(), d.getDate());
    }

    function formatDurationShort(totalSeconds) {
      const secs = Math.max(0, Math.floor(totalSeconds));
      const mins = Math.floor(secs / 60);
      const hrs = Math.floor(mins / 60);
      const remMins = mins % 60;
      if (hrs > 0) return `${hrs}h ${String(remMins).padStart(2, "0")}m`;
      return `${mins}m`;
    }

    function toLocalInputValue(ms) {
      const d = new Date(ms);
      if (Number.isNaN(d.getTime())) return "";
      const pad = (n) => String(n).padStart(2, "0");
      return `${d.getFullYear()}-${pad(d.getMonth() + 1)}-${pad(d.getDate())}T${pad(d.getHours())}:${pad(d.getMinutes())}`;
    }

    function fromLocalInputValue(value) {
      if (!value) return null;
      const d = new Date(value);
      const ms = d.getTime();
      if (Number.isNaN(ms)) return null;
      return ms;
    }

    function renderLockHistory() {
      if (!lockHistoryList) return;
      const entries = Array.isArray(state.lockHistory) ? state.lockHistory : [];
      const activeDay = selected ? new Date(selected.getFullYear(), selected.getMonth(), selected.getDate()) : new Date();
      const activeKey = dateKey(activeDay);
      const dayEntries = entries.filter((entry) => {
        const key = entry.dateKey || dateKey(new Date(entry.startedAt || 0));
        return key === activeKey;
      });
      const emptyEl = document.querySelector(".lock-history-empty");
      if (lockHistorySummary) {
        let daySeconds = 0;
        dayEntries.forEach((entry) => {
          const start = entry.startedAt || 0;
          const end = entry.endedAt || Date.now();
          daySeconds += Math.max(0, (end - start) / 1000);
        });
        if (state.activeLock && state.activeLock.startedAt && state.activeLock.dateKey === activeKey) {
          daySeconds += Math.max(0, (Date.now() - state.activeLock.startedAt) / 1000);
        }
        const goalMins = Number(state.settings.focusTargetMins ?? 120);
        const goalSecs = Math.max(0, goalMins * 60);
        const pct = goalSecs > 0 ? Math.min(100, Math.round((daySeconds / goalSecs) * 100)) : 0;
        lockHistorySummary.innerHTML = `
          <div class="lock-history-summary-bar">
            <div class="lock-history-summary-fill" style="width:${pct}%"></div>
          </div>
          <div class="lock-history-summary-labels">
            <span>${formatDurationShort(daySeconds)}</span>
            <div class="lock-history-goal-cell">
              <button class="lock-history-goal-link" type="button">
                <span>Goal:</span>
                <span>${formatDurationShort(goalSecs)}</span>
              </button>
              <input id="lockHistoryGoalInline" class="lock-history-goal-input-inline" type="number" min="10" step="5" />
            </div>
          </div>
        `;
        const goalInline = lockHistorySummary.querySelector("#lockHistoryGoalInline");
        if (goalInline) {
          goalInline.value = String(state.settings.focusTargetMins ?? 120);
          goalInline.addEventListener("change", () => {
            const next = Number(goalInline.value);
            if (Number.isNaN(next) || next <= 0) return;
            state.settings.focusTargetMins = next;
            save();
            syncScheduleUI();
            renderLockHistory();
            if (lockHistoryPanel) lockHistoryPanel.classList.remove("is-editing");
          });
        }
      }
      lockHistoryList.innerHTML = "";
      if (emptyEl) emptyEl.style.display = dayEntries.length ? "none" : "block";
      if (!dayEntries.length) return;

      dayEntries.forEach((entry) => {
        const item = document.createElement("div");
        item.className = "lock-history-item";

        const compact = document.createElement("div");
        compact.className = "lock-history-compact";

        const main = document.createElement("div");
        main.className = "lock-history-main";
        const startTime = new Date(entry.startedAt || 0).toTimeString().slice(0, 5);
        const endTime = new Date(entry.endedAt || entry.startedAt || 0).toTimeString().slice(0, 5);
        const durationSecs = Math.max(0, ((entry.endedAt || entry.startedAt || 0) - (entry.startedAt || 0)) / 1000);
        const timeEl = document.createElement("div");
        timeEl.className = "lock-history-time";
        timeEl.textContent = `${startTime}‚Äì${endTime}`;
        const taskEl = document.createElement("div");
        taskEl.className = "lock-history-task";
        taskEl.textContent = entry.task ? entry.task : "No task";
        main.append(timeEl, taskEl);

        const meta = document.createElement("div");
        meta.className = "lock-history-meta";
        meta.textContent = formatDurationShort(durationSecs);

        const editBtn = document.createElement("button");
        editBtn.className = "lock-history-edit-icon";
        editBtn.type = "button";
        editBtn.setAttribute("aria-label", "Edit entry");
        editBtn.addEventListener("click", () => {
          item.classList.toggle("is-editing");
        });

        const quickDeleteBtn = document.createElement("button");
        quickDeleteBtn.className = "lock-history-delete-icon";
        quickDeleteBtn.type = "button";
        quickDeleteBtn.setAttribute("aria-label", "Delete entry");
        quickDeleteBtn.addEventListener("click", () => {
          state.lockHistory = state.lockHistory.filter((e) => e.id !== entry.id);
          save();
          renderLockHistory();
        });

        compact.append(main, meta, editBtn, quickDeleteBtn);

        const edit = document.createElement("div");
        edit.className = "lock-history-edit";

        const startRow = document.createElement("div");
        startRow.className = "lock-history-row";
        const startLabel = document.createElement("div");
        startLabel.textContent = "Start";
        const startInput = document.createElement("input");
        startInput.type = "datetime-local";
        startInput.value = toLocalInputValue(entry.startedAt);
        startInput.addEventListener("change", () => {
          const next = fromLocalInputValue(startInput.value);
          if (!next) return;
          entry.startedAt = next;
          save();
          renderLockHistory();
        });
        startRow.append(startLabel, startInput);

        const endRow = document.createElement("div");
        endRow.className = "lock-history-row";
        const endLabel = document.createElement("div");
        endLabel.textContent = "End";
        const endInput = document.createElement("input");
        endInput.type = "datetime-local";
        endInput.value = toLocalInputValue(entry.endedAt);
        endInput.addEventListener("change", () => {
          const next = fromLocalInputValue(endInput.value);
          if (!next) return;
          entry.endedAt = next;
          save();
          renderLockHistory();
        });
        endRow.append(endLabel, endInput);

        const taskRow = document.createElement("div");
        taskRow.className = "lock-history-row";
        const taskLabel = document.createElement("div");
        taskLabel.textContent = "Task";
        const taskInput = document.createElement("input");
        taskInput.type = "text";
        taskInput.value = entry.task || "";
        taskInput.addEventListener("change", () => {
          entry.task = taskInput.value.trim();
          save();
          renderLockHistory();
        });
        taskRow.append(taskLabel, taskInput);

        const deleteBtn = document.createElement("button");
        deleteBtn.className = "mini-btn lock-history-delete";
        deleteBtn.type = "button";
        deleteBtn.textContent = "Delete";
        deleteBtn.addEventListener("click", () => {
          state.lockHistory = state.lockHistory.filter((e) => e.id !== entry.id);
          save();
          renderLockHistory();
        });

        edit.append(startRow, endRow, taskRow, deleteBtn);
        item.append(compact, edit);
        lockHistoryList.appendChild(item);
      });
    }

    function updateLockUI() {

      if (!lockBtn) return;

      const activeLock = state.activeLock && typeof state.activeLock.startedAt === "number" ? state.activeLock : null;

      if (activeLock) {
        lockBtn.disabled = false;
        lockBtn.classList.add("is-locked");
        if (lockinPanel) lockinPanel.classList.add("is-locked");
        if (panelCtaTextEl) panelCtaTextEl.textContent = "Unlock";
        if (panelElapsedEl) {
          const elapsedSecs = (Date.now() - activeLock.startedAt) / 1000;
          panelElapsedEl.textContent = formatDuration(elapsedSecs);
        }
        if (panelRangeEl) panelRangeEl.textContent = formatLockStart(activeLock);
        const lockedTask = (activeLock.task || "").trim();
        if (panelTaskEl) panelTaskEl.innerHTML = `Task: <span>${lockedTask || "‚Äî"}</span>`;
        return;
      }

      const now = new Date();

      if (!isSameDay(selected, now)) {
        lockBtn.disabled = true;
        panelRangeEl.textContent = "--:--";
        panelTaskEl.textContent = "Task: ‚Äî";
        lockBtn.classList.remove("is-locked");
        if (lockinPanel) lockinPanel.classList.remove("is-locked");
        return;
      }
      const info = getCurrentBlockInfo();
      if (!info) {
        lockBtn.disabled = true;
        panelRangeEl.textContent = "--:--";
        panelTaskEl.textContent = "Task: ‚Äî";
        lockBtn.classList.remove("is-locked");
        if (lockinPanel) lockinPanel.classList.remove("is-locked");
        return;
      }
      lockBtn.disabled = false;

      const dk = dateKey(selected);

      const label = blockLabel(info);

      const task = getSlotText(dk, info.timeKey).trim();

      panelRangeEl.textContent = label;

      panelTaskEl.innerHTML = `Task: <span>${task || "‚Äî"}</span>`;

      lockBtn.classList.remove("is-locked");
      if (lockinPanel) lockinPanel.classList.remove("is-locked");
      if (panelCtaTextEl) panelCtaTextEl.textContent = "Lock In";
      if (panelElapsedEl) panelElapsedEl.textContent = "";
    }



    function handleLockAction() {

      const now = new Date();

      if (state.activeLock && typeof state.activeLock.startedAt === "number") {
        const endedAt = Date.now();
        const lockEntry = {
          id: makeId(),
          startedAt: state.activeLock.startedAt,
          endedAt,
          dateKey: state.activeLock.dateKey,
          timeKey: state.activeLock.timeKey,
          task: state.activeLock.task || ""
        };
        state.lockHistory.unshift(lockEntry);
        if (state.activeLock.dateKey && state.activeLock.timeKey) {
          setBlockLocked(state.activeLock.dateKey, state.activeLock.timeKey, false);
        }
        state.activeLock = null;
        save();
        renderSchedule();
        updateLockUI();
        renderLockHistory();
        return;
      }

      if (!isSameDay(selected, now)) {

        showError("Select today to lock in.");

        return;

      }

      const info = getCurrentBlockInfo();

      if (!info) {

        showError("No active block right now.");

        return;

      }

      const dk = dateKey(selected);
      const task = getSlotText(dk, info.timeKey).trim();
      state.activeLock = {
        id: makeId(),
        startedAt: Date.now(),
        dateKey: dk,
        timeKey: info.timeKey,
        task
      };
      setBlockLocked(dk, info.timeKey, true);
      save();
      renderSchedule();
      updateLockUI();
    }


    if (lockBtn) {

      lockBtn.addEventListener("click", handleLockAction);

    }

    if (lockHistoryBtn && lockHistoryPop) {
      lockHistoryBtn.addEventListener("click", () => {
        if (lockHistoryDate) lockHistoryDate.value = toDateInputValue(selected);
        if (lockHistoryPanel) lockHistoryPanel.classList.remove("is-editing");
        renderLockHistory();
        openCenteredPopover(lockHistoryPop);
      });
    }

    if (lockHistoryDate) {
      lockHistoryDate.addEventListener("change", () => {
        const next = fromDateInputValue(lockHistoryDate.value);
        if (!next) return;
        setSelectedDate(next);
      });
    }

    if (lockHistoryPanel) {
      lockHistoryPanel.addEventListener("click", (e) => {
        const target = e.target;
        if (!(target instanceof Element)) return;
        if (!target.closest(".lock-history-goal-link")) return;
        lockHistoryPanel.classList.add("is-editing");
        const goalInline = lockHistorySummary ? lockHistorySummary.querySelector("#lockHistoryGoalInline") : null;
        if (goalInline) {
          goalInline.focus();
          goalInline.select();
        }
      });
    }




    function tickCountdown(forceTitle = false) {

      const blockInfo = getCurrentBlockInfo();

      if (!blockInfo) {

        countdownEl.textContent = "--:--";

        if (forceTitle) document.title = "Pomoplan";

        if (timerNowEl) timerNowEl.innerHTML = "Now: <span>?</span>";

        if (timerNextEl) timerNextEl.innerHTML = "Next: <span>?</span>";

        updateLockUI();

        return;

      }



      const mins = Math.floor(blockInfo.remainingSecs / 60);

      const secs = Math.max(0, blockInfo.remainingSecs % 60);

      const formatted = `${String(mins).padStart(2, "0")}:${String(secs).padStart(2, "0")}`;

      countdownEl.textContent = formatted;



      const dk = dateKey(selected);

      const task = getSlotText(dk, blockInfo.timeKey);

      const titleTask = task ? ` - ${task}` : "";

      document.title = `? ${formatted}${titleTask}`;



      if (timerNowEl && timerNextEl) {

        const nowText = (getSlotText(dk, blockInfo.timeKey) || "").trim();

        const nextTimeKey = TIMES[blockInfo.slotIndex + 1] ?? "";

        const nextText = nextTimeKey ? (getSlotText(dk, nextTimeKey) || "").trim() : "";

        timerNowEl.innerHTML = `Now: <span>${nowText || "No task scheduled"}</span>`;

        timerNextEl.innerHTML = `Next: <span>${nextText || "No task scheduled"}</span>`;

      }

      updateLockUI();

    }



    function init() {

      renderCalendar();

      renderTodos();

      renderSchedule();

      tickCountdown(true);

      updateNowLine();

      syncPanelHeights();

      if (welcomePop && shouldShowWelcome()) {

        setTimeout(() => openCenteredPopover(welcomePop), 250);

      }

    }



    init();



    setInterval(() => {

      tickCountdown();

      updateNowLine();

      checkSoundAlerts();

    }, 1000);



    function syncPanelHeights() {

      const calCard = document.querySelector(".col.left .card");

      const tCard = document.querySelector(".timer-card");

      if (!calCard || !tCard) return;

      const h = calCard.getBoundingClientRect().height;

      if (!h) return;

      tCard.style.height = `${Math.round(h)}px`;

      tCard.style.minHeight = `${Math.round(h)}px`;

    }



    window.addEventListener("resize", () => {

      syncPanelHeights();

    });

  </script>

</body>

</html>



